#!/usr/bin/env bash

set -e

##########################################
# log functions
##########################################

function inform {
    echo "[${SCRIPT_NAME}] INFO: $1"
}

function warn {
    echo "[${SCRIPT_NAME}] WARN: $1"
}

function simulate {
    echo "[${SCRIPT_NAME}] INFO: would execute \"$*\""
}

##########################################
# fail : try to restore
##########################################

# TODO: plenty - try to restore swap
# delete partitions in CREATED_PARTITIONS
# then use layout file created earlier with parted -sm /dev/?? unit s print to recreate

function clean {
    echo "[${SCRIPT_NAME}] INFO: cleanup"
    $UMOUNT ${MOUNT_DIR1}
    $UMOUNT ${MOUNT_DIR2}
    if [ -f ./tmp.img ] ; then
        rm ./tmp.img
    fi
}

##########################################
# fail : try to resotore & reboot
##########################################

function fail {
    echo "[${SCRIPT_NAME}] ERROR: $1"
    clean
    # reboot
    exit -1
}


# set TRUE if swap needs reenabling
RESTORE_SWAP=
# set TRUE if swap needs repartitioning
RESTORE_PART=
# list of partitions created
CREATED_PARTS=""


SCRIPT_NAME="resin-migrate-stage1"

inform "loading config"
SOURCE_DIR=$(dirname $0)
CFG_FILE="${SOURCE_DIR}/migrate-stage1.conf"
if [ -f ${CFG_FILE} ] ; then
    inform "loading ${CFG_FILE}"
    source ${CFG_FILE} || fail "failed to read config file ${CFG_FILE}"
else
    fail "failed to find config file ${CFG_FILE}"
fi

inform "establishing required programs"

CURL=$(which curl) || fail "could not find required command 'curl'"
DD=$(which dd) || fail "missing command: dd"
GREP=$(which grep) || fail "could not find required command 'grep'"
LOSETUP=$(which losetup) || fail "could not find required command 'losetup'"
MKDIR=$(which mkdir) || fail "missing command: mkdir"
MKFSE4=$(which mkfs.ext4) || fail "could not find required command 'mkfs.ext4'"
MKSWAP=$(which mkswap) || fail "could not find required command 'mkswap'"
MOUNT=$(which mount) || fail "missing command: mount"
PARTED=$(which parted) || fail "missing command: parted"
PARTED_READ=${PARTED}
RSYNC=$(which rsync) || fail "could not find required command 'rsync'"
SED=$(which sed) || fail "could not find required command 'sed'"
SWAPOFF=$(which swapoff) || fail "could not find required command 'swapoff'"
SWAPON=$(which swapon) || fail "could not find required command 'swapon'"
SWAPSTAT=$SWAPON
TUNE2FS=$(which tune2fs) || fail "could not find required command 'tune2fs'"
UMOUNT=$(which umount) || fail "missing command: umount"
GUNZIP=$(which gunzip) || fail "missing command: gunzip"
GZIP=$(which gzip) || fail "missing command: gzip"
FINDMNT=$(which findmnt) || fail "missing command: findmnt"
LSBLK=$(which lsblk) || fail "missing command: lsblk"
READLINK=$(which readlink) || fail "missing command: readlink"
FSCK=$(which fsck) || fail "missing command: fsck"
CHMOD=$(which chmod) || fail "missing command: chmod"
FDISK=$(which fdisk) || fail "missing command: fdisk"
TAR=$(which tar) || fail "missing command: tar"
# checkout grub
GRUBUPDT=$(which update-grub) || fail "could not find required command 'update-grub'"
GRUBREBOOT=$(which grub-reboot) || fail "could not find required command 'grub-reboot'"
GRUBINST=$(which grub-install) || fail "could not find required command 'grub-install'"
GRUB_STR=$($GRUBINST -V)
GRUB_VER=$(expr match "$GRUB_STR" '.*(GRUB).\([0-9]*\).*')
if (( GRUB_VER < GRUB_MIN_VER )) ; then
    fail "need at least grub verson $GRUB_MIN_VER but found `expr match "$GRUB_STR" '.*(GRUB).\(.*\)'`"
fi

inform "checked required programs"

##########################################
# split partition name into parts
# /dev/nvme0n1p1 -> "/dev/ nvme0n1 1 p"
##########################################

function splitPartName {
    local partName=$1
    local pathName=$(expr match "${partName}" '\(.*/\)[^/]\+')
    local tmpName1=$(${LSBLK} -no kname ${partName})
    local tmpName2=$(${READLINK} -f "/sys/class/block/${tmpName1}/..")
    local devName=$(basename "${tmpName2}")
    local tmp=${tmpName1:${#devName}}
    local pad=$(expr match "${tmp}" '\([^0-9]*\)[0-9]\+')
    local no=$(expr match "${tmp}" '[^0-9]*\([0-9]\+\)')
    echo "${pathName} ${devName} ${no} ${pad}"
}

##########################################
# check if list contains string
##########################################
# careful how you call it, should be
# eg.: listContains "$SUPPORTED_OSTYPES" $OSTYPE
function listContains {
    for CURR in $1
    do
        if [ "$2" == "$CURR" ]; then
            return 0
        fi
    done
    return -1
}

##########################################
# try to establish valid kernel version
#
##########################################
function checkKernel {
    VER=$(expr match "$1" '\([0-9]*\)')

    if (( VER < KERNEL_MIN_VER )) ; then
        return -1
    fi

    if  (( VER > KERNEL_MIN_VER )) ; then
        return 0
    fi

    MREV=$(expr match "$1" '[0-9]*.\([0-9]*\)')

    if (( MREV < KERNEL_MIN_MAJ_REV )) ; then
        return -1
    fi

    if (( MREV > KERNEL_MIN_MAJ_REV )) ; then
        return 0
    fi

    MREV=$(expr match "$1" '[0-9]*.[0-9]*.\([0-9]*\)')

    if (( MREV < KERNEL_MIN_MIN_REV )) ; then
        return -1
    else
        return 0
    fi
}

##########################################
# try to establish OS release
##########################################
checkOs() {
    if [ -f /etc/os-release ]; then
        local OS_ID=$($GREP -e ^ID= /etc/os-release | $SED "s/^ID=\(.*\)$/\1/")
        local OS_VERSION=$($GREP -e ^VERSION_ID= /etc/os-release | $SED -n 's/^VERSION_ID="\?\([^"]*\)"\?$/\1/p')
        VERSION="$OS_ID-$OS_VERSION"
    else
        # other methods for other osses
        # hostnamectrl
        # lsb_release -a
        # add methods as you add osses that need different methods from above
        VERSION=
    fi

    echo "$VERSION"
}

##########################################
# find suitable swap partition
##########################################
getSwapPart() {
    lineNo=0
    local found=
    local foundSize=0

    # Filename				Type		Size	Used	Priority
    # /dev/nvme0n1p7        partition	4194300	1280	-2

    while read line ;
    do
      lineNo=$(($lineNo + 1))

      if (( lineNo == 1 )) ; then
        # inform "skipping line 1"
        continue;
      fi


      # Name Type Size Used
      local parts=(${line})
      if [ "${parts[1]}" != "partition" ]; then
        # inform "not a partition ${line}, skipping"
        continue
      fi

      # echo "${parts[0]} type is OK: ${parts[1]}"

      local pSize=$((${parts[2]}))
      if (( pSize < $PART_MIN_SIZE )) ; then
        # inform "too little ${line}, skipping"
        continue;
      fi

      if (( pSize > foundSize )) ; then
        foundSize=$pSize
        found=${parts[0]}
      fi

      # TODO: check if swap is used excessively

    done < <(cat /proc/swaps)

    echo ${found}
}

function restoreSwap {
    if [ "$NO_RESTORE" == "TRUE" ] ; then
        warn "not restoring"
        return 0
    fi

    if [ -z "$SWAP_PART" ] ; then
        inform "restoreSwap: no swap device given"
        return -1
    fi

    if [ "$RESTORE_PART" == "TRUE" ] ; then
        inform "attempting to restore partition on $SWAP_PART"
        # TODO !!
    else
        inform "restoreSwap: swapspace does not appear to need repartitioning"
    fi

    if [ "$RESTORE_SWAP" == "TRUE" ] ; then
        inform "attempting to restore $SWAP_PART as swap"
        $UMOUNT $SWAP_PART || warn "unmount failed for $SWAP_PART - device might not have been mounted"
        $MKSWAP $SWAP_PART || warn "mkswap failed  for$SWAP_PART"
        $SWAPON $SWAP_PART || warn "swapon failed for $SWAP_PART"
    else
        inform "restoreSwap: swapspace does not appear to need restoring"
    fi
}


##########################################
# get disk & partition infos
##########################################
function getPartitionInfo {
    local hdDev=$1
    local hdNum=$2
    local parts=
    lastPart=0
    ORIG_PART_INFO=;

    while read line ;
    do
        # TODO: for restoring one option is to just store this original partition layout so it can be recreated

        # inform "getPartitionInfo line ${line}"

        ORIG_PART_INFO="${ORIG_PART_INFO}${line}"

        if [[ $line =~ ^[^:]+.$ ]] ; then
             continue
        fi

        IFS=':' read -ra parts <<< "$line"

        if [[ ! ${parts[0]} =~ ^[0-9]+$ ]] ; then
            DISK_SIZE=$(expr match "${parts[1]}" '\([0-9]\+\)s')
            SECTOR_SIZE=${parts[3]}
            MBR_TYPE=${parts[5]}
            inform "disk size ${DISK_SIZE} blocks, ${SECTOR_SIZE} bytes/sector '${MBR_TYPE}' partition type"
            continue;
        fi

        local currPartNo=${parts[0]}


        if (( $hdNum  == ${currPartNo} )) ; then
            PART_START=$(expr match "${parts[1]}" '\([0-9]\+\)s')
            PART_END=$(expr match "${parts[2]}" '\([0-9]\+\)s')
            PART_SIZE=$(expr match "${parts[3]}" '\([0-9]\+\)s')
            PART_TYPE="${parts[4]}"
            if [[ ! ${PART_TYPE} =~ ^.*swap.*$ ]] ; then
                fail "sanity check failed, not a swap partion"
            fi
            inform "partition start: ${PART_START}, end: ${PART_END}, size: ${PART_SIZE}, type: ${PART_TYPE}"
        fi

    done < <($PARTED_READ -ms ${hdDev} unit s print) || fail "failed to read partition infos"
    # inform "Original partition info: ${ORIG_PART_INFO}"

}

##########################################
# get space on drive
# params
#   path - will return the free space in the file system this path is in
##########################################
function getSpaceInFs {
    while read line ;
    do
        local parts=(${line})
        if [[  ${parts[2]} =~ [0-9]+ ]] ; then
            echo ${parts[2]}
            break;
        fi
    done < <(df $1 | tail -n +1) || fail "unable to retrieve space for $1"
}


##########################################
# get partition offsets by number
# params
#   device
#   startOffse
#   endOffse
##########################################
function getPartNo {
    local hdDev=$1
    local startOff=$2
    local endOff=$3
    local partNo=0

    while read line ;
    do
        if [[ ! ${line} =~ ^[0-9]+:.*$ ]] ; then
            continue
        fi

        IFS=':' read -ra parts <<< "${line}"

        local partStart=$(expr match "${parts[1]}" '\([0-9]\+\)s')
        local partEnd=$(expr match "${parts[2]}" '\([0-9]\+\)s')

        if (( ${partStart} == ${startOff} )) ; then
            if (( ${partEnd} == ${endOff} )) ; then
                partNo=${parts[0]}
                break
            fi
        else
            if (( ${partStart} > ${startOff} )) ; then
                break;
            fi
        fi
    done < <($PARTED_READ -ms $hdDev unit s print) || fail "failed to read ${hdDev} image partitions"
    echo $partNo
}


##########################################
# replicate image partition setup to swap space
##########################################

function makePartitions {

    local hdDev=$1
    local hdNum=$2
    local hdBaseName="${1}${3}"

    # TODO: check this
    # relying on this to be the last partition - else drive names would change for installed system
    # trying to create the flash images partition in the free space between $PART_START & $PART_END

    local parts=
    # local tgtPartNo=$hdNum # find out about partition number scheme
    local currStart=$PART_START

    if [ "${MBR_TYPE}" == "msdos" ] ; then
        if (( $hdNum < 5 )) ; then
            # create extended partition in available space
            inform "creating extended partition"
            $PARTED -sm ${hdDev} extended ${PART_START}s ${PART_END}s || fail "failed to create extended partition"
            partNo=$(getPartNo ${hdDev} ${PART_START} ${PART_END})
            if (( $partNo != 0 )) ; then
                CREATED_PARTS="${CREATED-PARTS} $partNo"
            fi
            local tmp=$(($currStart / $PART_ALIGN + 1))
            currStart=$(($tmp * $PART_ALIGN))
            inform "partStart: ${PART_START} currStart: ${currStart}"
        fi
    fi



    while read line ;
    do
        if [[ $line =~ ^[^:]+.$ ]] ; then
             continue
        fi

        IFS=':' read -ra parts <<< "$line"

        if [[ ! ${parts[0]} =~ ^[0-9]+$ ]] ; then
             IMG_DISK_SIZE=$(expr match "${parts[1]}" '\([0-9]\+\)s')
             IMG_SECTOR_SIZE=${parts[3]}
             IMG_MBR_TYPE=${parts[5]}
             inform "image size ${IMG_DISK_SIZE} blocks, ${IMG_SECTOR_SIZE} bytes/sector '${IMG_MBR_TYPE}' partition type"
             if (( $IMG_SECTOR_SIZE != $SECTOR_SIZE )) ; then
                fail "differing sector sizes are not yet implemented"
             fi
             if (( $IMG_MBR_TYPE != $MBR_TYPE )) ; then
                fail "differing mbr types are not yet implemented"
             fi

             # TODO: sanity check on size / sector size / partition types
             continue;
        fi

        local imgPartNo=${parts[0]}

        if (( $imgPartNo == 4 )) ; then
            # skip extended
            continue;
        fi

        if (( $imgPartNo == 6 )) ; then
            # do this outside, this way we tolerate part info files with missing trailing line break
            break;
        fi

        inform "copying image partition: ${imgPartNo}"

        local imgPartSize=${parts[3]}
        local imgPartStart=$(expr match "${parts[1]}" '\([0-9]\+\)s')
        local imgPartEnd=$(expr match "${parts[2]}" '\([0-9]\+\)s')
        local imgPartSize=$(expr match "${parts[3]}" '\([0-9]\+\)s')
        local imgPartType=${parts[4]}


        if (( $imgPartNo == 6 )) ; then
            # last partition gets all the space left
            local currPartEnd=${PART_END}
            local currPartSize=$((${currPartEnd} - ${currStart} + 1))
            imgPartType="ext4"
        else
            local currPartEnd=$(($currStart + $imgPartSize - 1))
            local currPartSize=${imgPartSize}
        fi

        $PARTED -sm ${hdDev} mkpart logical ${imgPartType} ${currStart}s ${currPartEnd}s || fail "failed to create partition"
        partNo=$(getPartNo ${hdDev} ${currStart} ${currPartEnd})

        if (($partNo == 0)) ; then
            fail "could not find target partion number for image partition ${imgPartNo}"
        fi

        CREATED_PARTS="${CREATED_PARTS} $partNo"

        case "${imgPartNo}" in
            1)
                inform "flash boot partition number is ${partNo}"
                FLASH_BOOT_PART_NO=${partNo}
                FLASH_BOOT_IMG_START=${imgPartStart}
                FLASH_BOOT_FS_TYPE=${imgPartType}
                FLASH_BOOT_PART_SIZE=${currPartSize}
            ;;
            2)
                inform "flash-rootA partition number is ${partNo}"
                FLASH_ROOTA_PART_NO=${partNo}
                FLASH_ROOTA_FS_TYPE=${imgPartType}
                FLASH_ROOTA_IMG_START=${imgPartStart}
                FLASH_ROOTA_PART_SIZE=${currPartSize}
            ;;
            3)
                inform "flash-rootB partition number is ${partNo}"
                FLASH_ROOTB_PART_NO=${partNo}
                FLASH_ROOTB_FS_TYPE=${imgPartType}
                FLASH_ROOTB_IMG_START=${imgPartStart}
                FLASH_ROOTB_PART_SIZE=${currPartSize}
            ;;
            5)
                inform "flash-state partition number is ${partNo}"
                FLASH_STATE_PART_NO=${partNo}
                FLASH_STATE_FS_TYPE=${imgPartType}
                FLASH_STATE_IMG_START=${imgPartStart}
                FLASH_STATE_PART_SIZE=${currPartSize}
            ;;
            6)
                break;
            ;;
            *)
                fail "unexpected image partition number ${imgPartNo}"
            ;;
        esac

        # TODO: try this
        #partprobe /dev/"$internal_dev"
        #udevadm trigger
        #udevadm settle

        local tmp=$(($currStart + $currPartSize))
        tmp=$(($tmp / $PART_ALIGN + 1))
        currStart=$(($tmp * $PART_ALIGN))

    done < "${FLASH_IMG_GEOMETRY_FILE}" || fail "failed to read ${FLASH_IMG_GEOMETRY_FILE}"

    # create data partition at end anyway

    $PARTED -sm ${hdDev} mkpart logical ext4 ${currStart}s ${PART_END}s || fail "failed to create flash-data partition"
    partNo=$(getPartNo ${hdDev} ${currStart} ${PART_END})
    CREATED_PARTS="${CREATED_PARTS} $partNo"

    inform "flash-data partition number is ${partNo}"
    FLASH_DATA_PART_NO=${partNo}
    FLASH_DATA_FS_TYPE="ext4"
    FLASH_DATA_PART="${hdBaseName}${partNo}"

    inform "creating ext4 filesystem on flash-data"
    $MKFSE4 ${hdBaseName}${partNo} || fail "failed to create fileSystem on flash-data ${hdBaseName}${partNo}"
    inform "labeling flash-data: $TUNE2FS -L flash-data ${hdBaseName}${partNo}"
    $TUNE2FS -L flash-data ${hdBaseName}${partNo} || fail "failed to label fileSystem on flash-data ${hdBaseName}${partNo}" || fail "failed to label {hdBaseName}${partNo} "
    sync

    inform "created partitions: ${CREATED_PARTS}"
    # $PARTED_READ -sm ${hdDev} print
}

##########################################
# find target partition and recreate
# parameter type linux-swap | ext4
##########################################

function initPartitions {
    local hdDev=$1
    local hdNameBase="${1}${2}"     # eg /dev/nvme0n1p

    if [ -z ${FLASH_IMG_FILE} ] ; then
        fail "flash image name is not set"
    fi

    if [ ! -d ${MOUNT_DIR1} ] ; then
        $MKDIR -p  ${MOUNT_DIR1}
    fi

    inform "attempting $MOUNT -t ${FLASH_DATA_FS_TYPE}  ${hdNameBase}${FLASH_DATA_PART_NO} ${MOUNT_DIR1}"
    $MOUNT -t ${FLASH_DATA_FS_TYPE}  ${hdNameBase}${FLASH_DATA_PART_NO} ${MOUNT_DIR1} || fail "failed to mount flash-data on ${hdBaseName}${partNo}"

    if [ ! -f ${FLASH_IMG_FILE} ] ; then
        if [ -z  ${FLASH_IMG_URL} ] ; then
             fail "no download url supplied for flasher image"
        fi
        inform "trying to download flasher image from ${FLASH_IMG_URL}"
        $CURL -o ${MOUNT_DIR1}/flasher.img.gz ${FLASH_IMG_URL} || fail "failed to download flasher image from ${FLASH_IMG_URL}"
        FLASH_IMG_FILE="${MOUNT_DIR1}/flasher.img.gz"
    fi

    if [[ "${FLASH_IMG_FILE}" =~ ^.*\.gz$ ]] ; then
        # it is gzipped
        inform "flashing from gzipped file ${FLASH_IMG_FILE}"
        inform "flashing flash-boot"
        $GUNZIP -c ${FLASH_IMG_FILE} | $DD of=${hdNameBase}${FLASH_BOOT_PART_NO} skip=${FLASH_BOOT_IMG_START} bs=${IMG_SECTOR_SIZE} count=${FLASH_BOOT_PART_SIZE} || fail "failed to initialize ${hdNameBase}${FLASH_BOOT_PART_NO}"
        inform "flashing flash-rootA"
        $GUNZIP -c ${FLASH_IMG_FILE} | $DD of=${hdNameBase}${FLASH_ROOTA_PART_NO} skip=${FLASH_ROOTA_IMG_START} bs=${IMG_SECTOR_SIZE} count=${FLASH_ROOTA_PART_SIZE} || fail "failed to initialize ${hdNameBase}${FLASH_ROOTA_PART_NO}"
        inform "flashing flash-rootB"
        $GUNZIP -c ${FLASH_IMG_FILE} | $DD of=${hdNameBase}${FLASH_ROOTB_PART_NO} skip=${FLASH_ROOTB_IMG_START} bs=${IMG_SECTOR_SIZE} count=${FLASH_ROOTB_PART_SIZE} || fail "failed to initialize ${hdNameBase}${FLASH_ROOTB_PART_NO}"
        inform "flashing flash-state"
        $GUNZIP -c ${FLASH_IMG_FILE} | $DD of=${hdNameBase}${FLASH_STATE_PART_NO} skip=${FLASH_STATE_IMG_START} bs=${IMG_SECTOR_SIZE} count=${FLASH_STATE_PART_SIZE} || fail "failed to initialize ${hdNameBase}${FLASH_STATE_PART_NO}"
    else
        inform "flashing from plain file ${FLASH_IMG_FILE}"
        inform "flashing flash-boot"
        $DD if=${FLASH_IMG_FILE} of=${hdNameBase}${FLASH_BOOT_PART_NO} skip=${FLASH_BOOT_IMG_START} bs=${IMG_SECTOR_SIZE} count=${FLASH_BOOT_PART_SIZE} || fail "failed to initialize ${hdNameBase}${FLASH_BOOT_PART_NO}"
        inform "flashing flash-rootA"
        $DD if=${FLASH_IMG_FILE} of=${hdNameBase}${FLASH_ROOTA_PART_NO} skip=${FLASH_ROOTA_IMG_START} bs=${IMG_SECTOR_SIZE} count=${FLASH_ROOTA_PART_SIZE} || fail "failed to initialize ${hdNameBase}${FLASH_ROOTA_PART_NO}"
        inform "flashing flash-rootB"
        $DD if=${FLASH_IMG_FILE} of=${hdNameBase}${FLASH_ROOTB_PART_NO} skip=${FLASH_ROOTB_IMG_START} bs=${IMG_SECTOR_SIZE} count=${FLASH_ROOTB_PART_SIZE} || fail "failed to initialize ${hdNameBase}${FLASH_ROOTB_PART_NO}"
        inform "flashing flash-state"
        $DD if=${FLASH_IMG_FILE} of=${hdNameBase}${FLASH_STATE_PART_NO} skip=${FLASH_STATE_IMG_START} bs=${IMG_SECTOR_SIZE} count=${FLASH_STATE_PART_SIZE} || fail "failed to initialize ${hdNameBase}${FLASH_STATE_PART_NO}"
    fi

    inform "deleting "
    rm ${FLASH_IMG_FILE}
    $UMOUNT ${MOUNT_DIR1}

    sync

    if [ "${CHECK_FS}" == "TRUE" ] ; then
        # TODO: sort out undefined FS types
        inform "checking copied file systems"
        $FSCK -t ${FLASH_BOOT_FS_TYPE} -p ${hdNameBase}${FLASH_BOOT_PART_NO} || warn "errors while checking file system on ${hdNameBase}${FLASH_BOOT_PART_NO}"
        $FSCK -t ${FLASH_ROOTA_FS_TYPE} -p ${hdNameBase}${FLASH_ROOTA_PART_NO} || warn "errors while checking file system on ${hdNameBase}${FLASH_ROOTA_PART_NO}"
        if [ -n "${FLASH_ROOTB_FS_TYPE}" ] ; then
            $FSCK -t ${FLASH_ROOTB_FS_TYPE} -p ${hdNameBase}${FLASH_ROOTB_PART_NO} || warn "errors while checking file system on ${hdNameBase}${FLASH_ROOTB_PART_NO}"
        fi
        if [ -n "${FLASH_STATE_FS_TYPE}" ] ; then
            $FSCK -t ${FLASH_STATE_FS_TYPE} -p ${hdNameBase}${FLASH_STATE_PART_NO} || warn "errors while checking file system on ${hdNameBase}${FLASH_STATE_PART_NO}"
        fi
    fi

    inform "initialized partitions: ${CREATED_PARTS}"

}


##########################################
# get partition number by offset
# params
#   device
#   startOffse
#   endOffse
##########################################
function getPartStartOffset {
    local hdDev=$1
    local partNo=$2

    while read line ;
    do
        if [[ $line =~ ^[^:]+.$ ]] ; then
             continue
        fi

        IFS=':' read -ra parts <<< "${line}"

        if [[ ! ${line} =~ ^[0-9]+:.*$ ]] ; then
            local sectorSize=${parts[3]}
            continue
        fi

        if (( ${parts[0]} != $partNo )) ; then
             continue
        fi

        local partStart=$(expr match "${parts[1]}" '\([0-9]\+\)s')
        partStart=$(($partStart * sectorSize))
        echo ${partStart}
        break;
    done < <(${PARTED_READ} -ms ${hdDev} unit s print) || fail "failed to read ${hdDev} image partitions"
}


##########################################
# setup grub boot configuration
##########################################


function setupGrub {
    # TODO: for now assuming we only have one device and we are on (hd0,X)
    if [ ! -d /etc/grub.d ] ; then
        fail "grub configuration not found"
    fi

    if [ -f /etc/grub.d/42_resin ] ; then
        rm /etc/grub.d/42_resin
    fi

    local hdDev=$1
    local partNum=$2



    # TODO: make grub HD num from hdDev, just assuming 0 for now
    local hdNum=0

    echo '#!/bin/sh' > /etc/grub.d/42_resin
    echo 'exec tail -n +3 $0' >> /etc/grub.d/42_resin
    cat <<EOT >> /etc/grub.d/42_resin
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.

menuentry "resin-migration" {
EOT
    echo "linux (hd${hdNum},${partNum})/vmlinuz root=LABEL=flash-rootA rootwait" >> /etc/grub.d/42_resin
    echo '}' >> /etc/grub.d/42_resin
    chmod +x /etc/grub.d/42_resin

    inform "updating grub config using ${GRUBUPDT}"
    $GRUBUPDT || fail "failed to update grub config"
    inform "calling ${GRUBREBOOT} resin-migration"
    $GRUBREBOOT resin-migration
}

##########################################
# getDiskId
##########################################
function getDiskId {
    local disk=$1
    local idLine=$(${FDISK} -l ${disk} | grep "Disk identifier:")
    local id=$(expr match "${idLine}" 'Disk identifier: \(.*\)')
    echo ${id}
}




##########################################
# setupMigration install image on swap
##########################################
function setupMigration {
    inform "preparing device for installation: $SWAP_PART"
    if [ -z "$SWAP_PART" ] ; then
        fail "no swap device "
    fi

    $SWAPOFF $SWAP_PART || fail "failed to disable swap"
    RESTORE_SWAP="TRUE"

    getPartitionInfo ${SWAP_DEV} ${SWAP_PART_NO}

    inform "removing swap partition"

    $PARTED -sm ${SWAP_DEV} rm ${SWAP_PART_NO} || fail "failed to remove swap partition"
    RESTORE_SWAP="TRUE"

    makePartitions ${SWAP_DEV} ${SWAP_PART_NO} ${SWAP_PART_PAD}

    initPartitions ${SWAP_DEV} ${SWAP_PART_PAD}

    # save information for stage 2

    # TODO: need to find a new way to identify drives
    # eg. enumerrate them like grub does

    inform "creating migrate-stage2.conf"

    $MOUNT "${SWAP_DEV}${SWAP_PART_PAD}${FLASH_ROOTA_PART_NO}" ${MOUNT_DIR1} || fail "failed to mount ${SWAP_DEV}${SWAP_PART_PAD}${FLASH_ROOTA_PART_NO} as ${MOUNT_DIR1}"
    inform "writing migrate conf to ${MOUNT_DIR1}/etc/migrate-stage2.conf"
    echo "#!/bin/sh " > ${MOUNT_DIR1}/etc/migrate-stage2.conf || fail "failed to write migrate-stage2.conf"
    # echo "ORIG_BOOT_DEV=${ORIG_ROOT_DEV}" >> ${MOUNT_DIR1}/etc/migrate-stage2.conf
    echo "ORIG_BOOT_DEV_ID=$(getDiskId ${ORIG_ROOT_DEV})" >> ${MOUNT_DIR1}/etc/migrate-stage2.conf
    echo "ORIG_ROOT_PART_NO=${ORIG_ROOT_PART_NO}" >> ${MOUNT_DIR1}/etc/migrate-stage2.conf
    echo "FLASH_DATA_PART_NO=${FLASH_DATA_PART_NO}" >> ${MOUNT_DIR1}/etc/migrate-stage2.conf
    # somehow flash-data label does not show up in stage 2
    # TODO: add links to customer provided delete & backup files here
    # echo "CUSTOMER_BACKUP_SCRIPT=" >> ${MOUNT_DIR1}/etc/migrate-stage2.conf
    # echo "CUSTOMER_DELETE_SCRIPT=" >> ${MOUNT_DIR1}/etc/migrate-stage2.conf

    cat ${MOUNT_DIR1}/etc/migrate-stage2.conf

    $CHMOD +x ${MOUNT_DIR1}/etc/migrate-stage2.conf

    $UMOUNT ${MOUNT_DIR1}



    # TODO: create backup here
    $MOUNT "${SWAP_DEV}${SWAP_PART_PAD}${FLASH_DATA_PART_NO}" ${MOUNT_DIR1} || fail "failed to mount ${SWAP_DEV}${SWAP_PART_PAD}${FLASH_DATA_PART_NO} as ${MOUNT_DIR1}"
    $TAR -czf ${MOUNT_DIR1}/backup_etc.tgz /etc/* || fail "failed to save backup on flasher-data"
    $UMOUNT ${MOUNT_DIR1}

    setupGrub ${SWAP_DEV} ${FLASH_BOOT_PART_NO}

    return 0
}


#################################
# MAIN
# check out environment
# fail & reboot if not approriate
# otherwise
# flash reduced image to swap drive
#
# USAGE: migrate-stage1.sh
#
#################################

if [ -z ${FLASH_IMG_GEOMETRY_FILE} ] ; then
    fail "FLASH_IMG_GEOMETRY_FILE is not defined"
else
    if [ ! -f ${FLASH_IMG_GEOMETRY_FILE} ] ; then
        fail "config file not found: ${FLASH_IMG_GEOMETRY_FILE}"
    fi
fi

if ! listContains "$SUPPORTED_OSTYPES" $OSTYPE ; then
    fail "not a supported OS type $OSTYPE"
fi

ARCH=$(uname -p)
KERNEL_VER=$(uname -r)
OS_VERSION=$(checkOs)

inform "OSTYPE: $OSTYPE"
inform "ARCH:   $ARCH"
inform "KERNEL: $KERNEL_VER"
inform "OS:     $OS_VERSION"

if ! checkKernel ${KERNEL_VER} ; then
    fail "unsupported kernel version ${KERNEL_VER}"
fi

if ! listContains "${SUPPORTED_OSSES}" ${OS_VERSION} ; then
    fail "not a supported OS ${OS_VERSION}"
fi

if ! listContains "${SUPPORTED_ARCHS}" $ARCH ; then
    fail "not a supported architecture ${ARCH}"
fi

ORIG_ROOT_PART=$(${FINDMNT} --noheadings --canonicalize --output SOURCE /)

TMP=($(splitPartName $ORIG_ROOT_PART))
ORIG_ROOT_DEV="${TMP[0]}${TMP[1]}"
ORIG_ROOT_PART_NO=${TMP[2]}
inform  "root is on ${ORIG_ROOT_DEV} partition ${ORIG_ROOT_PART_NO}"

SWAP_PART=$(getSwapPart)

if [ -z $SWAP_PART ]; then
    fail "no suitable device found for installation"
else
    inform "installation partition is $SWAP_PART"
fi

# inform "SWAP:   ${SWAP_PART}"

TMP=($(splitPartName $SWAP_PART))
SWAP_DEV="${TMP[0]}${TMP[1]}"
SWAP_PART_NO=${TMP[2]}
SWAP_PART_PAD=${TMP[3]}

inform "swap part: ${SWAP_PART}, swap dev: ${SWAP_DEV}, swap part no: ${SWAP_PART_NO}, swap part pad: ${SWAP_PART_PAD}"

if [[ $EUID -ne 0 ]]; then
    fail "This script must be run as root"
fi

if [ -z "$FLASH_IMG_FILE" ] ; then
    if [ ! -z "$FLASH_IMG_URL" ] ; then
        $CURL -o ./flash.img ${FLASH_IMG_URL} || fail "failed to downolad flasher image"
        FLASH_IMG_FILE=./flash.img
    fi
fi

if [ ! -f $FLASH_IMG_FILE ] ; then
    fail "no image found to flash"
else
    inform "flash image is ${FLASH_IMG_FILE} "
fi

if ! setupMigration ; then
    fail "failed to setup migration environment"
else
    inform "setup complete, rebooting"
    reboot
fi


