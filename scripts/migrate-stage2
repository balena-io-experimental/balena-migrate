#!/usr/bin/env bash

#
# Script which burns an image from an external device to an internal device
# Assumptions:
#   * image is in boot partition of external device
#   * all needed variables are configured in resin-init-flasher.conf
#   * filesystems labeling scheme is persistent (flasher-*/resin-*)
# Variables in resin-init-flasher.conf
#  INTERNAL_DEVICE_KERNEL                 - internal device (enumerated by kernel) to be flashed
#                                             * it's impossible to known what dev to flash because
#                                               we don't have any labels before flashing something
#                                               so we need this info
#                                             * when multiple entries provided, the first block device
#                                               found will be used
#  INTERNAL_DEVICE_BOOTLOADER_CONFIG      - name of the bootloader config for internal media boot
#  INTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH - relative path to internal boot partition where
#                                               INTERNAL_DEVICE_BOOTLOADER_CONFIG will be copied to
#  RESIN_IMAGE                            - image to be flashed on internal device
#                                             * this is defaulted to
#                                               resin-image-${MACHINE}.resinos-img and should be
#                                               just fine
#  BOOTLOADER_FLASH_DEVICE                - device where bootloader binary will be flashed
#                                             * this variable should be set together with
#                                               BOOTLOADER_IMAGE
#                                             * if this variable is not set we DO NOT flash u-boot
#                                               to internal flash device
#  BOOTLOADER_IMAGE                       - name of the u-boot binary
#  BOOTLOADER_BLOCK_SIZE_OFFSET           - offset at which we write u-boot binary
#  BOOTLOADER_SKIP_OUTPUT_BLOCKS          - number of blocks to skip when writing bootloader
#                                             * this is the seek param to dd
#
#  Certain hardware requires that the bootloader is split into MLO and u-boot.img rather than having
# it all bundled in a u-boot.img binary. To address this requirement, this flashing script will further
# look for variables called BOOTLOADER_FLASH_DEVICE_1, BOOTLOADER_IMAGE_1, BOOTLOADER_BLOCK_SIZE_OFFSET_1,
# BOOTLOADER_SKIP_OUTPUT_BLOCKS_1 to be used in the same way as BOOTLOADER_FLASH_DEVICE, BOOTLOADER_IMAGE,
# BOOTLOADER_BLOCK_SIZE_OFFSET, BOOTLOADER_SKIP_OUTPUT_BLOCKS so that user can specify both MLO and u-boot
# to be written in the respective devices.

set -e

# Very long variables :)
EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT=/mnt/boot # mounted by systemd
INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT=/tmp/mnt/internal_boot
# INTERNAL_DEVICE_CONF_PART_MOUNTPOINT=/tmp/internal_conf
INTERNAL_DEVICE_DATA_PART_MOUNTPOINT=/tmp/mnt/internal_data
FLASHER_CONF_FILE=/etc/resin-init-flasher.conf

# place this in flash-data instead to communicate with stage1 ?
MIGRATE_CONF_FILE=/etc/migrate-stage2.conf
# MIGRATE_CONF_FILE=/tmp/migrate-stage2.conf
FLASH_DATA_MOUNTPOINT=/tmp/mnt/flash-data
ORIG_ROOT_MOUNTPOINT=/tmp/mnt/orig-root
ORIG_ROOT_REQ_SPACE=2097152 # 2GB in K
CORE_IMG_FILE="/mnt/boot/grub/core.img" # "/mnt/boot/grub/core.img"
BOOT_IMG_FILE="/mnt/boot/grub/boot.img" # "/mnt/boot/grub/boot.img"

SPLASH_DIRNAME=splash
RESIN_BOOTLOADER_CONFIG=resinOS_uEnv.txt
CURRENT_ROOT=$(findmnt --noheadings --canonicalize --output SOURCE / | xargs lsblk -no pkname)

function clean {
    echo "[resin-init-flasher] Cleanup."
    umount ${INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT} > /dev/null 2>&1 || true
    # umount $INTERNAL_DEVICE_CONF_PART_MOUNTPOINT > /dev/null 2>&1 || true
}

function fail {
    echo "[resin-init-flasher] ERROR: $1"
    clean
    exit 1
}

function inform {
    echo "[resin-init-flasher] INFO: $1"
}

##########################################
# get space on drive
# params
#   path - will return the free space in the file system this path is in 1K blocks
##########################################
function getSpaceInFs {
    while read line ;
    do
        local parts=(${line})
        if [[  ${parts[2]} =~ [0-9]+ ]] ; then
            echo ${parts[2]}
            break;
        fi
    done < <(df -k $1 | tail -n +1) || fail "unable to retrieve space for $1"
}

##########################################
# get partition number by offset
# params
#   device
#   startOffse
#   endOffse
##########################################
function getPartStartOffset {
    local hdDev=$1
    local partNo=$2

    while read line ;
    do
        if [[ $line =~ ^[^:]+.$ ]] ; then
             continue
        fi

        IFS=':' read -ra parts <<< "${line}"

        if [[ ! ${line} =~ ^[0-9]+:.*$ ]] ; then
            local sectorSize=${parts[3]}
            continue
        fi

        if (( ${parts[0]} != $partNo )) ; then
             continue
        fi

        local partStart=$(expr match "${parts[1]}" '\([0-9]\+\)s')
        partStart=$(($partStart * $sectorSize))
        echo ${partStart}
        break;
    done < <(parted -ms ${hdDev} unit s print) || fail "failed to read ${hdDev} image partitions"
}

function getDeviceName {
    local devId=$1

    # Disk /dev/hda: 8 GiB, 8589934592 bytes, 16777216 sectors
    # Units: sectors of 1 * 512 = 512 bytes
    # Sector size (logical/physical): 512 bytes / 512 bytes
    # I/O size (minimum/optimal): 512 bytes / 512 bytes
    # Disklabel type: dos
    # Disk identifier: 0x000f073d


    while read line ;
    do
        if [[ $line =~ ^Disk\ identifier:\ .*$ ]] ; then
             local diskId=$(expr match "${line}" 'Disk identifier: \(.\+\)')
             # inform "found id ${diskId} for ${diskName}"
             if [ "${devId}" == "${diskId}" ] ; then
                echo ${diskName}
                break
             fi
        else
            if [[ ${line} =~ ^Disk\ .+$ ]] ; then
                 local diskName=$(expr match "${line}" 'Disk \([^:]\+\):.*')
                 # inform "looking at ${diskName}"
                 continue
            fi
        fi
    done < <(fdisk -l) || fail "failed to enumerate drives"
}

##########################################
# split partition name into parts
# /dev/nvme0n1p1 -> "/dev/ nvme0n1 1 p"
##########################################

function splitPartName {
    local partName=$1
    local pathName=$(dirname "${partName}")
    local tmpName1=$(lsblk -no kname ${partName})
    local tmpName2=$(readlink -f "/sys/class/block/${tmpName1}/..")
    local devName=$(basename "${tmpName2}")
    local tmp=${tmpName1:${#devName}}
    local pad=$(expr match "${tmp}" '\([^0-9]*\)[0-9]\+')
    local no=$(expr match "${tmp}" '[^0-9]*\([0-9]\+\)')
    echo "${pathName} ${devName} ${no} ${pad}"
}



########
# MAIN #
########

# Only root
if [ "$EUID" -ne 0 ]; then
    fail "Please run as root."
fi

# fail "dummy - not doing anything"

# TODO: if resin-init-board has to be run it needs to be adapted to use loop mounted image
# inform "Board specific initialization..."
# /usr/bin/resin-init-board

if [ -f ${MIGRATE_CONF_FILE} ] ; then
    source ${MIGRATE_CONF_FILE} || fail "failed to read migrate config file"
else
    fail "No migration configuration for resin-init-flasher."
fi


ORIG_BOOT_DEV=$(getDeviceName ${ORIG_BOOT_DEV_ID})

if [ -z "${ORIG_BOOT_DEV}" ] || [ ! -b ${ORIG_BOOT_DEV} ] ; then
    fail "could not identify boot device"
fi

inform "using device ${ORIG_BOOT_DEV}"

# Configuration file
if [ -f $FLASHER_CONF_FILE ]; then
    source $FLASHER_CONF_FILE
else
    fail "No configuration for resin-init-flasher."
fi
inform "resin-init-flasher configuration found."

# Resin configuration file
if [ -f /usr/sbin/resin-vars ]; then
    source /usr/sbin/resin-vars
else
    fail "No resin configuration found."
fi
inform "resin configuration found."

# CONFIG_PATH should exist
if [ ! -f "$CONFIG_PATH" ]; then
    fail "$CONFIG_PATH : No such file."
fi

## TODO: prepare and loopmount resinOS boot partition

FLASH_BOOTLOADER=
# Stuff from resin-init-flasher-board
if efibootmgr &>/dev/null ; then
    INSTALL_UEFI="TRUE"
else
    FLASH_BOOTLOADER="TRUE"
fi

# need to mount this now, won't work any more after flashing

FLASH_ROOT_PART=$(findmnt --noheadings --canonicalize --output SOURCE /)
TMP=($(splitPartName ${FLASH_ROOT_PART}))
FLASH_DATA_PART="${TMP[0]}/${TMP[1]}${TMP[3]}${FLASH_DATA_PART_NO}"
inform  "mounting flasher-data on ${FLASH_DATA_PART}"

mkdir -p ${FLASH_DATA_MOUNTPOINT}
mount ${FLASH_DATA_PART} ${FLASH_DATA_MOUNTPOINT} || fail "failed to mount flash-data"


inform "flashing resinOS image to ${ORIG_BOOT_DEV}"
gunzip -c /opt/${RESIN_IMAGE}.gz | dd of=${ORIG_BOOT_DEV} bs=4M || fail "failed to flash resinOS image to ${ORIG_BOOT_DEV}"

if [ "${FLASH_BOOTLOADER}" == "TRUE" ] ; then
    inform "flashing boot.img os to ${ORIG_BOOT_DEV}"
    dd if=${BOOT_IMG_FILE} of=${ORIG_BOOT_DEV} conv=fdatasync bs=1
    inform "flashing core.img os to ${ORIG_BOOT_DEV}"
    dd if=${CORE_IMG_FILE} of=${ORIG_BOOT_DEV} conv=fdatasync bs=1 seek=512
fi

sync

BOOT_START=$(getPartStartOffset  ${ORIG_BOOT_DEV} 1)
inform "boot part start offset: ${BOOT_START}"
mkdir -p "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT"
mount -o loop,offset=${BOOT_START} ${ORIG_BOOT_DEV} ${INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT} || fail "failed to mount new boot partition"

# Copy custom splash dir
mkdir -p "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/$SPLASH_DIRNAME"
cp -r $EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/$SPLASH_DIRNAME/* $INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/$SPLASH_DIRNAME
# Copy Network Manager connection files
CONFIG_NM="${CONFIG_PATH%/*}/system-connections/"
if [ -d "$CONFIG_NM" ]; then
    inform "Transferring system connections on the internal device."
    rm -rf "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/system-connections/"
    cp -rvf "$CONFIG_NM" "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT"
else
    inform "No system connections found to transfer on the internal device."
fi
# Copy proxy configuration files
CONFIG_PROXY="${CONFIG_PATH%/*}/system-proxy/"
if [ -d "$CONFIG_PROXY" ]; then
    inform "Transferring proxy configuration on the internal device."
    rm -rf "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/system-proxy/"
    cp -rvf "$CONFIG_PROXY" "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT"
else
    inform "No proxy configuration found to transfer on the internal device."
fi
# Copy bootloader config file

if [ -n "${INTERNAL_DEVICE_BOOTLOADER_CONFIG}" ] && [ -f "${EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT}/${INTERNAL_DEVICE_BOOTLOADER_CONFIG}" ]; then
        if [[ -z "${INTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH}" ]]; then
            fail "INTERNAL_DEVICE_BOOTLOADER_CONFIG needs INTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH to be set."
        fi

        cp "$EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/$INTERNAL_DEVICE_BOOTLOADER_CONFIG" "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/$INTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH"

        if [ -n "${INTERNAL_DEVICE_BOOTLOADER_LEGACY_CONFIG_PATH}" ]; then
            cp "$EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/$INTERNAL_DEVICE_BOOTLOADER_CONFIG" "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/$INTERNAL_DEVICE_BOOTLOADER_LEGACY_CONFIG_PATH"
        fi
fi

if [ -z $INSTALL_UEFI ]; then
    inform "non-UEFI installation."
    rm -rf "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/EFI"
else
    inform "UEFI installation."
    rm -rf "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/grub"
fi

# Copy resinOS bootloader config file
if [ -f "${EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT}/${RESIN_BOOTLOADER_CONFIG}" ]; then
        cp $EXTERNAL_DEVICE_BOOT_PART_MOUNTPOINT/$RESIN_BOOTLOADER_CONFIG $INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT
fi

# Give a chance for the device to register
STARTTIME=$(date +%s)
ENDTIME="$STARTTIME"
TIMEOUT=10
while [ "$(systemctl is-active resin-device-register.service)" != "active" ]
do
    if [ $((ENDTIME - STARTTIME)) -le $TIMEOUT ]; then
        sleep 1 && ENDTIME=$((ENDTIME + 1))
    else
        inform "Timeout while waiting for register to finish. No network?"
        break
    fi
done

# Copy json configuration file from external (flasher) to the internal (booting) device
cp -rvf "$CONFIG_PATH" "$INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT"

sync
umount ${INTERNAL_DEVICE_BOOT_PART_MOUNTPOINT}


DATA_START=$(getPartStartOffset  ${ORIG_BOOT_DEV} 6)
inform "resin-data part start offset: ${BOOT_START}"
mkdir -p "${INTERNAL_DEVICE_DATA_PART_MOUNTPOINT}"
mount -o loop,offset=${DATA_START} ${ORIG_BOOT_DEV} ${INTERNAL_DEVICE_DATA_PART_MOUNTPOINT} || fail "failed to mount resin-data partition"

cp -rax ${FLASH_DATA_MOUNTPOINT}/backup* ${INTERNAL_DEVICE_DATA_PART_MOUNTPOINT}/
sync
umount ${FLASH_DATA_MOUNTPOINT}
umount ${INTERNAL_DEVICE_DATA_PART_MOUNTPOINT}

inform "rebooting device ..."
reboot
