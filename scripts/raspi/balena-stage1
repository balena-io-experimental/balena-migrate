#!/bin/bash
####################################################################
# strategy
# DEFAULT: copy os image & backup to initramfs, unmount root, reflash drive,
#          partprobe and mount resin-data to copy backup, reboot
# RESIZE:  unfinished - resize root file system & partition in local-premount
#          use the space to store balenaOS image & backup
####################################################################
STRATEGY="DEFAULT"
# where everything is
# TODO: establish & use an absolute path to a set home directory that is not
#       necessarily PWD
HOME_DIR=./
# reboot automatically after script has finished by setting to "TRUE"
DO_REBOOT= # "TRUE"
# name of the balenaOS image to flash (expected in $HOMEDIR)
# IMAGE_NAME="resin-image-genericx86-64.resinos-img.gz"
IMAGE_NAME="resin-resintest-raspberrypi3-2.15.1+rev2-dev-v7.16.6.img.gz"

# switch on initramfs / kernel debug mode by seting to "TRUE"
DEBUG="TRUE"

# name of backup file to create/transfer to balena-data
BACKUP_FILE=backup.tgz
# TODO: customer defined backup script to call
BACKUP_SCRIPT=
BACKUP_DIRECTORIES="/etc"

# Grub boot devices
GRUB_BOOT_DEV="hd0,msdos1"
GRUB_BOOT_TYPE="legacy"

# DEBUG end initramfs scripts before unmounting root / flashing the image
NO_FLASH= #"TRUE"
ERROR_EXIT= # "reboot -f"

# DEBUG: do not modify config.txt if set to "TRUE"
NO_SETUP= #"TRUE"
# create initramfs in contrast to using an initramfs supplied
MK_INITRAMFS="TRUE"
# name of initramfs to be created/used expected in $HOMEDIR
INITRAMFS_NAME="balena-migrate-initramfs-$(uname -r)"
# DEBUG verbose build process
MK_INITRAM_VERBOSE= # "TRUE"
# DEBUG keep initramfs layout
MK_INITRAM_RETAIN= # "TRUE"

# attempt to mount and log initramfs logs to external drive if set
LOG_DRIVE=/dev/sda1
LOG_FS_TYPE=ext4

HAS_WIFI_CFG="FALSE" # set to "TRUE" if a wifi config is provided in image
MIGRATE_ALL_WIFIS="FALSE" # migrate all wifis if set to "TRUE"
MIGRATE_WIFI_CFG="migrate-wifis" # file with a list of wifi networks to migrate, one per line

# where the migrate conf is created - DO NOT MODIFY hardcoded in initramfs scripts
MIGRATE_CONF=/etc/balena-migrate.conf

# raspi config.txt to modify
CONFIG_TXT="/boot/config.txt"
# raspi cmdline.txt to modify
CMDLINE_TXT="/boot/cmdline.txt"

SUPPORTED_OSSES="ubuntu-14.04 raspbian-9"
SUPPORTED_ARCHS="x86_64 armv7l"

RASPI_1_REVS="0002 0003 0004 0005 0006 0007 0008 0009 000d 000e 000f 0010 0011 0012 0013 0014 0015 900092 900093	920093 9000c1 900021 900032 900092 900093 920093 9000c1"
RASPI_2_REVS="a01040 a01041 a21041 a22042"
RASPI_3_REVS="a02082 a020a0 a22082 a32082 a020d3"

GRUB_MIN_VER=2
BOOT_DIR=/boot
# script namme for logging
SCRIPT_NAME="balena-stage1"


##########################################
# log functions
##########################################

function inform {
    echo "[$(date +%T) ${SCRIPT_NAME}] INFO: $1"
}

function warn {
    echo "[$(date +%T) ${SCRIPT_NAME}] WARN: $1"
}

function simulate {
    echo "[$(date +%T) ${SCRIPT_NAME}] INFO: would execute \"$*\""
}

function clean {
    if [ -n "${CONFIG_TXT_BACKUP}" ] ; then
        cp ${CONFIG_TXT_BACKUP} ${CONFIG_TXT}
    fi
}

##########################################
# fail : try to resotore & reboot
##########################################

function fail {
    echo "[$(date +%T) ${SCRIPT_NAME}] ERROR: $1"
    clean
    exit -1
}

##########################################
# check if list contains string
##########################################
# careful how you call it, should be
# eg.: listContains "$SUPPORTED_OSTYPES" $OSTYPE
function listContains {
    local res="FALSE"
    for curr in $1
    do
        if [ "$2" == "$curr" ]; then
            res="TRUE"
            break;
        fi
    done
    echo $res
}

##########################################
# check if programs are available
##########################################

function checkPgms {
  for pgm in $*
  do
      local pgmPath="$(whereis -b $pgm | awk '{ print $2}')"
      if [ -z "$pgmPath" ] || [ ! -f "$pgmPath" ] ; then
        fail "cannot find required program: $pgm as $pgmPath"
     fi
  done
}


##########################################
# try to establish OS release
##########################################
checkOs() {
    if [ -f /etc/os-release ]; then
        local OS_ID=$(grep -e ^ID= /etc/os-release | sed "s/^ID=\(.*\)$/\1/")
        local OS_VERSION=$(grep -e ^VERSION_ID= /etc/os-release | sed -n 's/^VERSION_ID="\?\([^"]*\)"\?$/\1/p')
        VERSION="$OS_ID-$OS_VERSION"
    else
        # other methods for other osses
        # hostnamectrl
        # lsb_release -a
        # add methods as you add osses that need different methods from above
        VERSION=
    fi

    echo "$VERSION"
}

##########################################
# create a network manager wifi file
##########################################

function create_nmgr_file {
  local WIFI_NO=$1
  local WIFI_SSID=$2
  local WIFI_PSK=$3
  local FILE_NAME="resin-wifi-`printf %02d $WIFI_NO`"

  cat << EOI > ${FILE_NAME}
  [connection]
  id=$FILE_NAME
  type=wifi

  [wifi]
  hidden=true
  mode=infrastructure
  ssid=${WIFI_SSID}

  [wifi-security]
  auth-alg=open
  key-mgmt=wpa-psk
  psk=${WIFI_PSK}

  [ipv4]
  method=auto

  [ipv6]
  addr-gen-mode=stable-privacy
  method=auto
EOI
if [ -z "$NETWORK_CONFIGS" ] ; then
  NETWORK_CONFIGS="$FILE_NAME"
else
  NETWORK_CONFIGS="$NETWORK_CONFIGS $FILE_NAME"
fi
}

####################################################################################
# wether to migrate a ssid
####################################################################################

function migrate_this_wifi {
  local ssid="$*"
  # inform "migrate_this_wifi: ssid=<${ssid}>"
  local res="FALSE"
  if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] ; then
    res="TRUE"
  else
      if [ -f "$MIGRATE_WIFI_CFG" ] ; then
          while read line
          do
            if [ "$line" == "$ssid" ] ; then
              res="TRUE"
              break
            fi
          done < "$MIGRATE_WIFI_CFG"
      fi
  fi
  echo $res
}

####################################################################################
# extract wifi network config from wpa_supplicant.conf
####################################################################################

function wificfg_from_wpa {
  local cfgNo=1
  if [ "$HAS_WIFI_CFG" == "TRUE" ] ; then
    cfgNo=2
  fi

  while read line ;
  do
      if [[ $line =~ ^\s*network\s*=\s*\{ ]] ; then
        # inform "wificfg_from_wpa: found network in <${line}>"
        local network="TRUE"
        local ssid=
        local psk=
      else
        if [ "$network" == "TRUE" ] ; then
          if [[ $line =~ ^\s*} ]] ; then
            if [ -n "$ssid" ] && [ -n "$psk" ] ; then
                create_nmgr_file $cfgNo "$ssid" "$psk"
                cfgNo=$((cfgNo + 1))
                ssid=
                psk=
            fi
            continue
          fi

          if [[ $line =~ ^\s*ssid\s*= ]] ; then
            local tmpSsid=$(expr match "$line" '\s*ssid\s*=\s*"\([^"]\+\)"')

            if [ -z "$tmpSsid" ] ; then
              tmpSsid=$(expr match "$line" '\s*ssid\s*=\s*\(\S\+\)')
            fi
            local res=$(migrate_this_wifi $tmpSsid)
            if [ "$res" == "TRUE" ] ; then
              ssid=$tmpSsid
            fi
            continue
          fi

          if [[ $line =~ ^\s*psk\s*= ]] ; then
            # inform "wificfg_from_wpa: psk in line : <${line}>"
            psk=$(expr match "$line" '\s*psk\s*=\s*"\([^"]\+\)"')
            if [ -z "$psk" ] ; then
              psk=$(expr match "$line" '\s*psk\s*=\s*\(\S\+\)')
            fi
            # inform "wificfg_from_wpa: psk: <${psk}>"
            continue
          fi
        fi
      fi
  done < /etc/wpa_supplicant/wpa_supplicant.conf
}

##########################################
# migrate/copy NetworkManager files
##########################################

function wificfg_from_nmgr {
  local cfgNo=1
  if [ "$HAS_WIFI_CFG" == "TRUE" ] ; then
    cfgNo=2
  fi

  for file in /etc/NetworkManager/system-connections/*; do
    local grepRes=$(grep -E "^\s*type\s*=\s*wifi" "$file")
    if [ -z "$grepRes" ] ; then
      continue
    fi
    grepRes=$(grep -E "^\s*ssid\s*=.*" "$file")
    local currSsid=$(expr match "$grepRes" 'ssid\s*=\s*\(.*\)')

    local res="$(migrate_this_wifi $currSsid)"

    if [ "$res" == "TRUE" ] ; then
      inform "migrating wifi config for $currSsid"
      # TODO: only extract certain params or copy the whole thing ?
      local fileName="resin-wifi-`printf %02d $cfgNo`"
      cp "$file" "$fileName"
      cfgNo=$((cfgNo + 1))
    fi
  done
}

##########################################
# split partition name into parts
# /dev/nvme0n1p1 -> "/dev/ nvme0n1 1 p"
##########################################

function splitPartName {
    local partName=$1
    local pathName=$(dirname "${partName}")
    local tmpName1=$(lsblk -no kname ${partName})
    local tmpName2=$(readlink -f "/sys/class/block/${tmpName1}/..")
    local devName=$(basename "${tmpName2}")
    local tmp=${tmpName1:${#devName}}
    local pad=$(expr match "${tmp}" '\([^0-9]*\)[0-9]\+')
    local no=$(expr match "${tmp}" '[^0-9]*\([0-9]\+\)')
    echo "${pathName} ${devName} ${no} ${pad}"
}

##########################################
# check armvX arch  device
##########################################

function checkArmDevs {
  RPI_HW_REV=$(awk '/^Revision/ {sub("^1000", "", $3); print $3}' /proc/cpuinfo)
  inform "RPI_HW_REV=$RPI_HW_REV"
  IS_PI1=$(listContains "${RASPI_1_REVS}" ${RPI_HW_REV})
  if [ "$IS_PI1" == "TRUE" ] ; then
    IS_PI="TRUE"
    inform "device is a Raspberry PI 1"
    if [[ ! $IMAGE_NAME =~ raspberrypi1 ]] ; then
      fail "expected raspberrypi1 image, got $IMAGE_NAME"
    fi
  else
      IS_PI2=$(listContains "${RASPI_2_REVS}" ${RPI_HW_REV})
      if [ "$IS_PI2" == "TRUE" ] ; then
        IS_PI="TRUE"
        inform "device is a Raspberry PI 2"
        if [[ ! $IMAGE_NAME =~ raspberrypi2 ]] ; then
          fail "expected raspberrypi2 image, got $IMAGE_NAME"
        fi
      else
        IS_PI3=$(listContains "${RASPI_3_REVS}" ${RPI_HW_REV})
        if [ "$IS_PI3" == "TRUE" ] ; then
          IS_PI="TRUE"
          inform "device is a Raspberry PI 3"
          if [[ ! $IMAGE_NAME =~ raspberrypi3 ]] ; then
            fail "expected raspberrypi3 image, got $IMAGE_NAME"
          fi
        else
          fail "no known PI revision found: $RPI_HW_REV"
        fi
      fi
  fi
}



####################################################
## setup raspbery pi to boot using initramfs
####################################################

function setupBootCfg_rpi {
  inform "setupBootCfg_rpi"
  ##########################
  ## Modify /boot/config.txt
  ##########################

  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} cp cat rm sleep"
  inform "making backup of config.txt"
  CONFIG_TXT_BACKUP="${CONFIG_TXT}.$(date +%Y%m%d-%H-%M-%S)"
  TMP_FILE=$(mktemp)
  INITRAM_CMD="initramfs ${INITRAMFS_NAME} followkernel"

  # make sure BUSYBOX is NOT used
  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1n/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"

  while read -r line
  do
    if [[ $line =~ ^\s*\# ]] ; then
      echo $line >> $TMP_FILE
      continue
    fi

    if [[ $line =~ ^\s*initramfs ]] ; then
      if [ "$line" != "$INITRAM_CMD" ] ; then
        echo "# $line" >> $TMP_FILE
      fi
    else
      echo $line >> $TMP_FILE
    fi
  done < "${CONFIG_TXT}"
  echo $INITRAM_CMD >> $TMP_FILE
  cp $TMP_FILE $CONFIG_TXT
  rm $TMP_FILE

  ###########################
  ## Modify /boot/cmdline.txt
  ###########################

  if [ "$DEBUG" == "TRUE" ] ; then
    CMD_LINE=$(cat ${CMDLINE_TXT})
    if [[ ! $CMD_LINE =~ debug ]] ; then
      inform "making backup of ${CMDLINE_TXT}"
      CMDLINE_TXT_BACKUP="${CMDLINE_TXT}.$(date +%Y%m%d-%H-%M-%S)"
      cp ${CMDLINE_TXT}  ${CMDLINE_TXT_BACKUP}
    	CMD_LINE="${CMD_LINE} debug"
    	echo $CMD_LINE > cmdline.txt
    fi
  fi

}

####################################################
## setup intel device to boot with initramfs
####################################################

function setupBootCfg_other {
  inform "setupBootCfg_other"
  # TODO: grub boot device is set in $GRUB_BOOT_DEV - try to determine it from setup (eg. grub.conf)
  # TODO: assuming we are on debian like OS

  # BOOT_IMAGE=/boot/vmlinuz-4.4.0-31-generic root=UUID=1bddfe9b-69cd-499d-bd21-2639700a899e ro

  # TODO: this is ublikely to work but I will try it
  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} grub-install busybox"

  # make sure BUSYBOX is used
  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1y/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"

  local efiBootMgr=$(whereis -b efibootmgr | awk '{ print $2}')
  if [ -n "$efiBootMgr" ] &&  efibootmgr &>/dev/null ; then
    GRUB_BOOT_TYPE="UEFI"
    INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} efibootmgr"
  fi

  local KERNEL_CMD_LINE_RAW=$(cat /proc/cmdline)
  if [ -z "$KERNEL_CMD_LINE_RAW" ] ; then
    fail "no kernel command line"
  fi

  case "$KERNEL_CMD_LINE_RAW" in
     BOOT_IMAGE=*)
        # Ubuntu version
        local KERNEL_CMD_LINE=$(expr match "$KERNEL_CMD_LINE_RAW" '^BOOT_IMAGE=\(.*\)')
        # local KERNEL_CMD_LINE="vmlinuz-4.4.0-31-generic root=UUID=1bddfe9b-69cd-499d-bd21-2639700a899e ro"
        local TMP=($KERNEL_CMD_LINE)
        KBOOT_DIR=$(dirname ${TMP[0]})
        ;;
        *)
          fail "not a known command line format $KERNEL_CMD_LINE_RAW"
        ;;
  esac

  if [[ ! "$KERNEL_CMD_LINE" =~ boot= ]] ; then
    KERNEL_CMD_LINE="$KERNEL_CMD_LINE boot=local"
  fi


  if [ "$DEBUG" == "TRUE" ] ; then
    if [[ ! "$KERNEL_CMD_LINE" =~ debug ]] ; then
      KERNEL_CMD_LINE="$KERNEL_CMD_LINE debug"
    fi
  fi

  inform "KERNEL_CMD_LINE=$KERNEL_CMD_LINE"
  # inform "BOOT_DIR=$BOOT_DIR"

  if [ "$KBOOT_DIR" != "/boot" ] ; then
    # boot config does not appear to be on root partition
    if [ "$KBOOT_DIR" == "." ] ; then
      $KBOOT_DIR=
    else
      $KBOOT_DIR="$KBOOT_DIR/"
    fi

    local BOOT_PART_INFO=($(df -l --output=source,target | grep -E "\\s+/boot$"))
    if [ -n "$BOOT_PART_INFO" ] ; then
        # but it is mounted as /boot
        BOOT_DIR=/boot
    else
        # try find it
        local BOOT_PART_RAW=$(parted -sm $ROOT_DEV print | grep -E "(:|,)boot(,|;)")
        if [ -z "$BOOT_PART_RAW" ] ; then
           fail "could not find boot partition on $ROOT_DEV"
        fi

        # inform "BOOT_PART_RAW=$BOOT_PART_RAW"
        local BOOT_PART_NUM=$(expr match "$BOOT_PART_RAW" '^\([^:]\+\):.*')

        mkdir -p /mnt/tmp-boot || fail "failed to create mount dir /mnt/tmp-boot"
        mount "${ROOT_DEV}${ROOT_PAD}${BOOT_PART_NUM}" /mnt/tmp-boot || fail "failed to mount ${ROOT_DEV}${ROOT_PAD}${BOOT_PART_NUM} on  /mnt/tmp-boot"
        BOOT_DIR=/mnt/tmp-boot
    fi
  else
    KBOOT_DIR="${KBOOT_DIR}/"
  fi

  if [ -z "$(whereis -b update-grub)" ] || [ -z "$(whereis -b grub-reboot)" ] ; then
      fail "failed to ensure required programs update-grub, grub-reboot"
  fi

  if [ ! -d /etc/grub.d ] ; then
      fail "grub configuration not found"
  fi

# TODO: make grub HD num from hdDev, just assuming 0 for now

  GRUB_INSTALL="TRUE"
  local grubDev=$(expr match "$GRUB_BOOT_DEV" '^\([^,]\+\),.*')
  echo "(${grubDev}) $ROOT_DEV" > ${HOME_DIR}/device.map

  cat << EOI > ${HOME_DIR}/grub.cfg
serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1
default=boot
timeout=0

menuentry 'boot'{
linux /vmlinuz root=LABEL=resin-rootA rootwait quiet loglevel=0 splash udev.log-priority=3 vt.global_cursor_default=0 intel_idle.max_cstate=1
}
EOI

cat <<EOI > /etc/grub.d/42_resin
#!/bin/sh
exec tail -n +3 \$0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.

menuentry "resin-migration" {
  insmod part_msdos
  insmod ext2

  set root='$GRUB_BOOT_DEV'
  linux $KERNEL_CMD_LINE
  initrd  ${KBOOT_DIR}${INITRAMFS_NAME}
}
EOI
chmod +x /etc/grub.d/42_resin

  inform "updating grub config using ${GRUBUPDT}"
  update-grub || fail "failed to update grub config"
  inform "calling grub-reboot resin-migration"
  grub-reboot resin-migration
}

####################################################################################
####################################################################################
# main : create initramfs & install it
####################################################################################
####################################################################################

if [[ $EUID -ne 0 ]]; then
    fail "This script must be run as root"
fi

inform "establishing required programs"

# TODO: Check / install tools needed for initramfs too

INITRAM_REQUIRED_PGMS="mkdir dd gzip df parted echo reboot partprobe sync dirname lsblk udevadm"
REQUIRED_PGMS="lsblk readlink mkinitramfs sed" #  gzip
checkPgms $REQUIRED_PGMS

inform "checked required programs"

inform "checking required files"
if [[ ! $HOME_DIR =~ ^/.* ]] ; then
  CURR_DIR=$(pwd)
  cd $HOME_DIR || fail "invalid/non existant HOME_DIR: $HOME_DIR"
  HOME_DIR=$(pwd)
  cd $CURR_DIR
fi

if [ ! -d "$HOME_DIR" ] ; then
  fail "homedir does not exist: $HOME_DIR"
fi

inform "HOME_DIR=$HOME_DIR"

if [ ! -f "${HOME_DIR}/$IMAGE_NAME" ] ; then
  fail "missing image file: ${HOME_DIR}/$IMAGE_NAME"
fi


##########################################
# detect device / check for correct image ?
##########################################

ARCH=$(uname -m)

if [ ! "$(listContains "$SUPPORTED_ARCHS" $ARCH)" == "TRUE" ] ; then
  fail "not a supported architecture: $ARCH"
fi

case $ARCH in
  armv*)
    checkArmDevs
    ;;
  x86_64)
    inform "ARCH=$ARCH"
    if [[ ! $IMAGE_NAME =~ genericx86-64 ]] ; then
        fail "expected genericx86-64 image, got $IMAGE_NAME"
    fi
    ;;
  *)
    fail "unknown / unsupported architecture: $ARCH"
    ;;
esac

checkPgms $INITRAM_REQUIRED_PGMS

KERNEL_VER=$(uname -r)
inform "KERNEL_VER=$KERNEL_VER"

OS_VERSION=$(checkOs)
inform "OS_VERSION=$OS_VERSION"

RES=$(listContains "${SUPPORTED_OSSES}" ${OS_VERSION})
# inform "listContains \"${SUPPORTED_OSSES}\" ${OS_VERSION} = <${RES}>"
if [ "$RES" != "TRUE" ] ; then
    fail "not a supported OS ${OS_VERSION}"
fi

if [ "$MK_INITRAMFS" == "TRUE" ] && [ ! -d "${HOME_DIR}/initramfs-tools" ] ; then
  fail "missing image directory: ${HOME_DIR}/initramfs-tools"
fi

ROOT_FS=$(findmnt --noheadings --canonicalize --output SOURCE /)
TMP=($(splitPartName ${ROOT_FS}))

PAD=${TMP[3]}
ROOT_DEV=${TMP[0]}/${TMP[1]}

inform "ROOT_DEV=${ROOT_DEV}"

###########################
## create boot configuration
###########################

if [ ! "$NO_SETUP" == "TRUE" ] ; then
  inform "boot setup enabled: NO_SETUP=$NO_SETUP"
  if [ "$IS_PI" == "TRUE" ] ; then
    inform "performing boot setup for RPI: $IS_PI"
    setupBootCfg_rpi
  else
    inform "performing boot setup for other: $IS_PI"
    setupBootCfg_other
  fi
else
  inform "boot setup disabled: NO_SETUP=$NO_SETUP"
fi



###########################
## write /etc/migrate.conf
###########################

cat <<EOI > ${MIGRATE_CONF}
#!/bin/sh
# DO NOT EDIT ! This file is supposed to be created by stage1 script

REQUIRED_PGMS="$INITRAM_REQUIRED_PGMS"
LOG_DRIVE=${LOG_DRIVE}
LOG_FS_TYPE=${LOG_FS_TYPE}
LOG_MOUNT_DIR=/extlog
LOG_FILE=migrate.log

STRATEGY=${STRATEGY}
ROOT_DEV=${ROOT_DEV}
HOME_DIR=${HOME_DIR}
IMAGE_FILE=${IMAGE_NAME}
BACKUP_FILE=${BACKUP_FILE}

MIGRATE_TMP=/balena-migrate

BOOT_MNT_DIR=/resin-boot
BOOT_PART_NAME=${ROOT_DEV}${PAD}1         # resinOS-boot part name
BOOT_PART_TYPE=vfat                        # resinOS-boot fs type

DATA_MNT_DIR=/resin-data
DATA_PART_NAME=${ROOT_DEV}${PAD}6         # resinOS-data part name
DATA_PART_TYPE=ext4                       # resinOS-data fs type

NO_FLASH=${NO_FLASH}
ERROR_EXIT=${ERROR_EXIT}

GRUB_INSTALL=${GRUB_INSTALL}
GRUB_BOOT_TYPE=${GRUB_BOOT_TYPE}

EOI

#####################################
## USE: resize strategy - unfinished
#####################################

if [ "$STRATEGY" == "RESIZE" ] ; then
  cat <<EOI >> ${MIGRATE_CONF}
MEM_MIN_AVAIL=600000
MEM_TMPFS_SIZE=512M
RESIZE_FS="${ROOT_FS}"
RESIZE_DEV=${ROOT_DEV}
RESIZE_PART_NO=${TMP[2]}
# TODO: actually calculate this
RESIZE_PART_START=94208
RESIZE_PART_END=31116287
RESIZE_PART_TYPE=primary
RESIZE_PART_FS=ext4
RESIZE_PART_TO=26921984
RESIZE_PART_SIZE=26827777

NEW_PART_TYPE="primary"
NEW_PART_FS="ext2"
NEW_PART_START=26926080
NEW_PART_TO=31022087
NEW_PART_NAME=/dev/mmcblk0p3
REQUIRED_PGMS="$INITRAM_REQUIRED_PGMS"
EOI
fi

###########################
## migrate network config
###########################

if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] || [ -n "$MIGRATE_WIFI_CFG" ] ; then
  NETWORK_CONFIGS=
  if [ -f /etc/wpa_supplicant/wpa_supplicant.conf ] ; then
    wificfg_from_wpa
  else
    if [ -d /etc/NetworkManager/system-connections/ ] ; then
      wificfg_from_nmgr
    else
      warn "no supported wifi config found"
    fi
  fi

  if [ -n "$NETWORK_CONFIGS" ] ; then
    echo "NETWORK_CONFIGS=\"$NETWORK_CONFIGS\"" >> ${MIGRATE_CONF}
    echo "" >> ${MIGRATE_CONF}
  fi
fi

###########################
## create initramfs
###########################

if [ "${MK_INITRAMFS}" == TRUE ] ; then
    OPTS="-d ${HOME_DIR}/initramfs-tools -o ${HOME_DIR}/${INITRAMFS_NAME}"
    if [ "$MK_INITRAM_VERBOSE" == "TRUE" ] ; then
      OPTS="-v $OPTS"
    fi

    if [ "$MK_INITRAM_RETAIN" == "TRUE" ] ; then
      OPTS="-k $OPTS"
    fi

    inform "creating initramfs: mkinitramfs $OPTS"
    mkinitramfs $OPTS || fail "failed to create initramfs in ${HOME_DIR}/${INITRAMFS_NAME}"

    inform "copying ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"
    cp ${HOME_DIR}/${INITRAMFS_NAME} "${BOOT_DIR}/" || fail "failed to copy ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"
fi

###########################
## create backup
###########################

if [ -n "$BACKUP_DIRECTORIES" ] ; then
  inform "creating backup in ${HOME_DIR}/$BACKUP_FILE"
  if [ -f "${HOME_DIR}/$BACKUP_FILE" ] ; then
    rm ${HOME_DIR}/$BACKUP_FILE || true
  fi

  tar -czf ${HOME_DIR}/$BACKUP_FILE $BACKUP_DIRECTORIES
  inform "done creating backup"
  # TODO: check / restrict size of backup file
fi

###########################
## create backup
###########################

if [ "$DO_REBOOT" == "TRUE" ] ; then
  inform "rebooting system in 5 seconds"
  sleep 5
  reboot
fi
