#!/bin/bash

DATA_MOUNT_POINT="/mnt/resin-data"
MIGRATEFS_MOUNT_POINT="/mnt/resin-migrate"
LOG_FILE="/var/log/resin-migrate.log" #/dev/stdout
MEM_MIN_AVAIL=600000
MEM_TMPFS_SIZE=512000000
SCRIPT_NAME="raspi-migrate-stage2"
BACKUP_FILE="/backup_etc.tgz"

CONFIG_FILE="/etc/resin-migrate.conf"

IMAGE_FILE="/backup_etc.tgz"


TOOLS_REQUIRED="ls dd mount umount parted fuser systemctl grep expr kill sh bash whereis sleep tar gzip mkdir sync date"

set -e

function inform {
    echo "[$(date +%T) ${SCRIPT_NAME}] INFO: $1" >> ${LOG_FILE}
}

function warn {
    echo "[$(date +%T) ${SCRIPT_NAME}] WARN: $1" >> ${LOG_FILE}
}

function simulate {
    echo "[$(date +%T) ${SCRIPT_NAME}] INFO: would execute \"$*\"" >> ${LOG_FILE}
}

##########################################
# fail : try to restore
##########################################

# TODO: plenty - try to restore swap
# delete partitions in CREATED_PARTITIONS
# then use layout file created earlier with parted -sm /dev/?? unit s print to recreate

function clean {
    echo "[$(date +%T) ${SCRIPT_NAME}] INFO: cleanup" >> ${LOG_FILE}
    $UMOUNT ${MOUNT_DIR1}
    $UMOUNT ${MOUNT_DIR2}
    if [ -f ./tmp.img ] ; then
        rm ./tmp.img
    fi
}

##########################################
# fail : try to resotore & reboot
##########################################

function fail {
    echo "[$(date +%T) ${SCRIPT_NAME}] ERROR: $1" >> ${LOG_FILE}
    if [ "${ROOT_RW}"="TRUE" ] ; then
        mount -oremount,ro /
    fi
    exit -1
}

##########################################
# copyPgm copy program and libraries required
##########################################

function copyPgm {
    pgmName=$1

    inform "copyPgm ${pgmName}"

    if [ -z "${2}" ] ; then
        target=${target}
    else
        target=$2
    fi

    local tmp=($(whereis -b ${pgmName})) || fail "required program not found ${pgmName}"
    inform "whereis reports: ${tmp[1]}"

    local idx=1
    inform "got ${#tmp[@]} results"
    while [ $idx -lt ${#tmp[@]} ] ;
    do
        inform "$idx : ${tmp[$idx]}"
        local pgmPath=${tmp[$idx]}
        if [ ! -d "$pgmPath" ] && [ -x "$pgmPath" ] ; then
            inform "$pgmPath is executable"
            break;
        fi
        idx=$(($idx + 1))
    done

    if [ -d "$pgmPath" ] || [ ! -x "$pgmPath" ] ; then
        fail "failed to find executable for ${pgmName}"
    fi

    inform "copying pgm name: ${pgmName} : ${pgmPath}"

    dirPath=$(dirname ${pgmPath})

    if [ ! -z "${dirPath}" ] && [ ! -d dirPath ] ; then
        local tgtPath="${target}${dirPath}"
        mkdir -p ${tgtPath}
    fi

    cp ${pgmPath}  ${tgtPath}/ 2>>${LOG_FILE}

    while read line ;
    do
        # inform "process: $line"

        if [[ ${line} =~ ^not\ a\ dynamic\ executable.*$ ]]  ; then
          break;
        fi

        if [[ ${line} =~ ^linux-vdso.*$ ]] ; then
            continue
        fi

        if [[ ${line} =~ ^.*\ =\>\ .*$ ]] ; then
            local tmp=$(expr match "${line}" '.* => \(.*\)')
        else
            local tmp=${line}
        fi

        # inform "tmp: ${tmp}"
        parts=(${tmp})

        libPath=${parts[0]}

        # inform "attempting to copy ${libPath}"
        dirPath=$(dirname ${libPath})
        if [ ! -z "${dirPath}" ] && [ ! -d dirPath ] ; then
            tgtPath="${target}${dirPath}"
            mkdir -p ${tgtPath}
        fi

        if [ ! -f "${target}${libPath}" ] ; then
            cp ${libPath}  ${tgtPath}/ 2>>${LOG_FILE}
            inform "${libPath} copied to ${tgtPath}/"
        fi

    done < <(ldd ${pgmPath})
}

##########################################
# get partition number by offset
# params
#   device
#   startOffse
#   endOffse
##########################################
function getPartStartOffset {
    local hdDev=$1
    local partNo=$2

    while read line ;
    do
        if [[ $line =~ ^[^:]+.$ ]] ; then
             continue
        fi

        IFS=':' read -ra parts <<< "${line}"

        if (( ${parts[0]} != $partNo )) ; then
             continue
        fi

        local partStart=$(expr match "${parts[1]}" '\([0-9]\+\)s')
        partStart=$(($partStart * $sectorSize))
        echo ${partStart}
        break;
    done < <(parted -ms ${hdDev} unit s print) || fail "failed to read ${hdDev} image partitions"
}


##########################################
# main:
##########################################



ROOT_RO=$(grep "\s/\s.*\sro[\s,]" /proc/mounts) || warn "OK"

if [ -n "${ROOT_RO}" ] ; then
    mount -oremount,rw / || exit -1
    ROOT_RW="TRUE"
fi
inform "test root remounted: ${ROOT_RW}"

inform "systemctl:"
systemctl >> ${LOG_FILE} 2>&1
inform "df:"
df >> ${LOG_FILE} 2>&1


COUNTER=0
while [  $COUNTER -lt 20 ]; do
 inform "The counter is ${COUNTER}"
 let COUNTER=COUNTER+1
 sleep 1
done

inform "systemctl:"
systemctl >> ${LOG_FILE} 2>&1
inform "df:"
df >> ${LOG_FILE} 2>&1

inform "all good"

if [ "${ROOT_RW}" == "TRUE" ] ; then
    mount -oremount,ro /
    ROOT_RW="FALSE"
fi



# sleep 10

