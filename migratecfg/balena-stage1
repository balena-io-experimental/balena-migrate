#!/bin/bash
####################################################################
# strategy
# DEFAULT: copy os image & backup to initramfs, unmount root, reflash drive,
#          partprobe and mount resin-data to copy backup, reboot
# RESIZE:  unfinished - resize root file system & partition in local-premount
#          use the space to store balenaOS image & backup
####################################################################

####################################################################
# TODO: parted not installed on default beaglebone debian install,
#       install or replace
# TODO: remove non DEFAULT strategies ?
####################################################################

STRATEGY="DEFAULT"
# where everything is
# TODO: establish & use an absolute path to a set home directory that is not
#       necessarily PWD
HOME_DIR=./
# reboot automatically after script has finished by setting to "TRUE"
DO_REBOOT= # "TRUE"
# name of the balenaOS image to flash (expected in $HOMEDIR)
# IMAGE_NAME="resin-image-genericx86-64.resinos-img.gz"
# IMAGE_NAME="resin-resintest-raspberrypi3-2.15.1+rev2-dev-v7.16.6.img.gz"

# switch on initramfs / kernel debug mode by seting to "TRUE"
DEBUG= # "TRUE"

# name of backup file to create/transfer to balena-data
BACKUP_FILE=backup.tgz
# TODO: customer defined backup script to call
BACKUP_SCRIPT=
BACKUP_DIRECTORIES="/etc"

# Grub boot devices
GRUB_BOOT_DEV="hd0"
GRUB_BOOT_TYPE="legacy"

# DEBUG end initramfs scripts before unmounting root / flashing the image
NO_FLASH= #"TRUE"
# what to do when terminating due to NO_FLASH=TRUE
TERM_EXIT="exit 0" # "reboot -f"

# DEBUG: do not modify config.txt, cmdline.txt, grub config if set to "TRUE"
NO_SETUP= #{ }"TRUE"
# create initramfs in contrast to using an initramfs supplied
MK_INITRAMFS="TRUE"
# DEBUG verbose build process
MK_INITRAM_VERBOSE= # "TRUE"
# DEBUG keep initramfs layout
MK_INITRAM_RETAIN= # "TRUE"

# attempt to mount and log initramfs logs to external drive if set
LOG_DRIVE=/dev/sdb1
LOG_FS_TYPE=ext4

HAS_WIFI_CFG="FALSE" # set to "TRUE" if a wifi config is provided in image
MIGRATE_ALL_WIFIS="FALSE" # migrate all wifis if set to "TRUE"
MIGRATE_WIFI_CFG="migrate-wifis" # file with a list of wifi networks to migrate, one per line
BALENA_WIFI= # if set to TRUE attempt to extract a wifi config from config.json given in BALENA_CONFIG

BALENA_CONFIG= # set to the path of a config.json file to copy to the image


##########################################
# log functions
##########################################

function inform {
    echo "[$(date +%T) ${SCRIPT_NAME}] INFO: $1"
}

function warn {
    echo "[$(date +%T) ${SCRIPT_NAME}] WARN: $1"
}

function simulate {
    echo "[$(date +%T) ${SCRIPT_NAME}] INFO: would execute \"$*\""
}

function clean {
    if [ -n "${CONFIG_TXT_BACKUP}" ] ; then
        cp ${CONFIG_TXT_BACKUP} ${CONFIG_TXT}
    fi
}

##########################################
# fail : try to resotore & reboot
##########################################

function fail {
    echo "[$(date +%T) ${SCRIPT_NAME}] ERROR: $1"
    clean
    exit -1
}

##########################################
# check if list contains string
##########################################
# careful how you call it, should be
# eg.: listContains "$SUPPORTED_OSTYPES" $OSTYPE
function listContains {
    local res="FALSE"
    for curr in $1
    do
        if [ "$2" == "$curr" ]; then
            res="TRUE"
            break;
        fi
    done
    echo $res
}

##########################################
# check if programs are available
##########################################

function checkPgms {
  for pgm in $*
  do
      local pgmPath="$(whereis -b $pgm | awk '{ print $2}')"
      if [ -z "$pgmPath" ] || [ ! -f "$pgmPath" ] ; then
        fail "cannot find required program: $pgm as $pgmPath"
     fi
  done
}


##########################################
# try to establish OS release
##########################################
checkOs() {
    if [ -f /etc/os-release ]; then
        local OS_ID=$(grep -e ^ID= /etc/os-release | sed "s/^ID=\(.*\)$/\1/")
        local OS_VERSION=$(grep -e ^VERSION_ID= /etc/os-release | sed -n 's/^VERSION_ID="\?\([^"]*\)"\?$/\1/p')
        VERSION="$OS_ID-$OS_VERSION"
    else
        # other methods for other osses
        # hostnamectrl
        # lsb_release -a
        # add methods as you add osses that need different methods from above
        VERSION=
    fi

    echo "$VERSION"
}

##########################################
# create a network manager wifi file
##########################################

function create_nmgr_file {
  local WIFI_NO=$1
  local WIFI_SSID=$2
  local WIFI_PSK=$3
  local FILE_NAME="resin-wifi-`printf %02d $WIFI_NO`"

  cat << EOI > ${FILE_NAME}
  [connection]
  id=$FILE_NAME
  type=wifi

  [wifi]
  hidden=true
  mode=infrastructure
  ssid=${WIFI_SSID}

  [wifi-security]
  auth-alg=open
  key-mgmt=wpa-psk
  psk=${WIFI_PSK}

  [ipv4]
  method=auto

  [ipv6]
  addr-gen-mode=stable-privacy
  method=auto
EOI
if [ -z "$NETWORK_CONFIGS" ] ; then
  NETWORK_CONFIGS="$FILE_NAME"
else
  NETWORK_CONFIGS="$NETWORK_CONFIGS $FILE_NAME"
fi
}

####################################################################################
# wether to migrate a ssid
####################################################################################

function migrate_this_wifi {
  local ssid="$*"
  # inform "migrate_this_wifi: ssid=<${ssid}>"
  local res="FALSE"
  if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] ; then
    res="TRUE"
  else
      if [ -f "$MIGRATE_WIFI_CFG" ] ; then
          while read line
          do
            if [ "$line" == "$ssid" ] ; then
              res="TRUE"
              break
            fi
          done < "$MIGRATE_WIFI_CFG"
      fi
  fi
  echo $res
}

####################################################################################
# extract wifi network config from wpa_supplicant.conf
####################################################################################

function wificfg_from_wpa {
  local cfgNo=1
  if [ "$HAS_WIFI_CFG" == "TRUE" ] ; then
    cfgNo=2
  fi

  while read line ;
  do
      if [[ $line =~ ^\s*network\s*=\s*\{ ]] ; then
        # inform "wificfg_from_wpa: found network in <${line}>"
        local network="TRUE"
        local ssid=
        local psk=
      else
        if [ "$network" == "TRUE" ] ; then
          if [[ $line =~ ^\s*} ]] ; then
            if [ -n "$ssid" ] && [ -n "$psk" ] ; then
                create_nmgr_file $cfgNo "$ssid" "$psk"
                cfgNo=$((cfgNo + 1))
                ssid=
                psk=
            fi
            continue
          fi

          if [[ $line =~ ^\s*ssid\s*= ]] ; then
            local tmpSsid=$(expr match "$line" '\s*ssid\s*=\s*"\([^"]\+\)"')

            if [ -z "$tmpSsid" ] ; then
              tmpSsid=$(expr match "$line" '\s*ssid\s*=\s*\(\S\+\)')
            fi
            local res=$(migrate_this_wifi $tmpSsid)
            if [ "$res" == "TRUE" ] ; then
              ssid=$tmpSsid
            fi
            continue
          fi

          if [[ $line =~ ^\s*psk\s*= ]] ; then
            # inform "wificfg_from_wpa: psk in line : <${line}>"
            psk=$(expr match "$line" '\s*psk\s*=\s*"\([^"]\+\)"')
            if [ -z "$psk" ] ; then
              psk=$(expr match "$line" '\s*psk\s*=\s*\(\S\+\)')
            fi
            # inform "wificfg_from_wpa: psk: <${psk}>"
            continue
          fi
        fi
      fi
  done < /etc/wpa_supplicant/wpa_supplicant.conf
}

##########################################
# migrate/copy NetworkManager files
##########################################

function wificfg_from_nmgr {
  local cfgNo=1
  if [ "$HAS_WIFI_CFG" == "TRUE" ] ; then
    cfgNo=2
  fi

  for file in /etc/NetworkManager/system-connections/*; do
    local grepRes=$(grep -E "^\s*type\s*=\s*wifi" "$file")
    if [ -z "$grepRes" ] ; then
      continue
    fi
    grepRes=$(grep -E "^\s*ssid\s*=.*" "$file")
    local currSsid=$(expr match "$grepRes" 'ssid\s*=\s*\(.*\)')

    local res="$(migrate_this_wifi $currSsid)"

    if [ "$res" == "TRUE" ] ; then
      inform "migrating wifi config for $currSsid"
      # TODO: only extract certain params or copy the whole thing ?
      local fileName="resin-wifi-`printf %02d $cfgNo`"
      cp "$file" "$fileName"
      cfgNo=$((cfgNo + 1))
    fi
  done
}

##########################################
# split partition name into parts
# /dev/nvme0n1p1 -> "/dev/ nvme0n1 1 p"
##########################################

function splitPartName {
    local partName=$1
    local pathName=$(dirname "${partName}")
    local tmpName1=$(lsblk -no kname ${partName})
    local tmpName2=$(readlink -f "/sys/class/block/${tmpName1}/..")
    local devName=$(basename "${tmpName2}")
    local tmp=${tmpName1:${#devName}}
    local pad=$(expr match "${tmp}" '\([^0-9]*\)[0-9]\+')
    local no=$(expr match "${tmp}" '[^0-9]*\([0-9]\+\)')
    echo "${pathName} ${devName} ${no} ${pad}"
}

##########################################
# get root info
# get info about the mount point and path
# to /root
##########################################
function getBootInfo {
  if [ ! -d /boot ] ; then
    fail "boot directory could not be found"
  fi

  ROOT_FS=$(findmnt --noheadings --canonicalize --output SOURCE /)
  if [ -z "$ROOT_FS" ] ; then
    fail "root mount point could not be found"
  fi

  BOOT_FS=$(findmnt --noheadings --canonicalize --output SOURCE /boot)

  if [ -z "$BOOT_FS" ] ; then
    BOOT_FS=$ROOT_FS
  fi

  EFI_FS=$(findmnt --noheadings --canonicalize --output SOURCE /boot/efi)
}


##########################################
# check armvX arch  device
##########################################

function checkArmDevs {
  # local sysName=$(expr match "$(uname -a)" '^Linux \([ ]\+\)')
  local sysName=$(expr match "$(uname -a)" '^Linux \([^ ]\+\)')
  inform "platform is <${sysName}>"

  case "$sysName" in
    raspberrypi)
      inform "detected raspberry PI"
      RPI_HW_REV=$(awk '/^Revision/ {sub("^1000", "", $3); print $3}' /proc/cpuinfo)
      inform "RPI_HW_REV=$RPI_HW_REV"
      local IS_PI1=$(listContains "${RASPI_1_REVS}" ${RPI_HW_REV})
      if [ "$IS_PI1" == "TRUE" ] ; then
        devType="armv7_rpi1"
        inform "device is a Raspberry PI 1"
        if [[ ! $IMAGE_NAME =~ raspberrypi1 ]] ; then
          fail "expected raspberrypi1 image, got $IMAGE_NAME"
        fi
      else
          local IS_PI2=$(listContains "${RASPI_2_REVS}" ${RPI_HW_REV})
          if [ "$IS_PI2" == "TRUE" ] ; then
            devType="armv7_rpi2"
            inform "device is a Raspberry PI 2"
            if [[ ! $IMAGE_NAME =~ raspberry-pi2 ]] ; then
              fail "expected raspberrypi2 image, got $IMAGE_NAME"
            fi
          else
            local IS_PI3=$(listContains "${RASPI_3_REVS}" ${RPI_HW_REV})
            if [ "$IS_PI3" == "TRUE" ] ; then
              devType="armv7_rpi1"
              inform "device is a Raspberry PI 3"
              if [[ ! $IMAGE_NAME =~ raspberrypi3 ]] ; then
                fail "expected raspberrypi3 image, got $IMAGE_NAME"
              fi
            else
              fail "no known PI revision found: $RPI_HW_REV"
            fi
          fi
      fi
    ;;
    beaglebone)
      # eg.: TI AM335x BeagleBone Green
      local tmp=$(cat /proc/device-tree/model)
      local variant=$(expr match "$tmp" '.* BeagleBone \([^ ]\+\)')

      inform "detected Beaglebone $variant device"

      case "$variant" in
        Green)
          if [[ ! $IMAGE_NAME =~ beaglebone-green ]] ; then
            fail "expected beaglebone-green image, got $IMAGE_NAME"
          fi
          devType="armv7_bb_green"
        ;;
        *)
          fail "not a supported Beaglebone variant: $variant"
        ;;
      esac
    ;;
    *)
      fail "unrecognized arm hardware platform: $sysName, 'uname -a' reports: $(uname -a)"
    ;;
  esac
}



####################################################
## setup raspbery pi to boot using initramfs
####################################################

function setupBootCfg_rpi {
  inform "setupBootCfg_rpi"
  ##########################
  ## Modify /boot/config.txt
  ##########################

  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} cp cat rm sleep"

  # make sure BUSYBOX is NOT used
  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1n/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"
  sed -i 's/^\(MODULES\s*=\s*\).*$/\1list/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"


  if [ "$NO_SETUP" != "TRUE" ] ; then
    RESTORE_BOOT="TRUE"

    CONFIG_TXT_BACKUP="${CONFIG_TXT}.$(date +%Y%m%d-%H-%M-%S)"
    cp ${CONFIG_TXT}  ${CONFIG_TXT_BACKUP}
    inform "created backup of ${CONFIG_TXT} in ${CONFIG_TXT_BACKUP}"

    TMP_FILE=$(mktemp)
    INITRAM_CMD="initramfs ${INITRAMFS_NAME} followkernel"


    while read -r line
    do
      if [[ $line =~ ^\s*\# ]] ; then
        echo $line >> $TMP_FILE
        continue
      fi

      if [[ $line =~ ^\s*initramfs ]] ; then
        if [ "$line" != "$INITRAM_CMD" ] ; then
          echo "# $line" >> $TMP_FILE
        fi
      else
        echo $line >> $TMP_FILE
      fi
    done < "${CONFIG_TXT}"
    echo $INITRAM_CMD >> $TMP_FILE
    cp $TMP_FILE $CONFIG_TXT
    rm $TMP_FILE

    ###########################
    ## Modify /boot/cmdline.txt
    ###########################

    if [ "$DEBUG" == "TRUE" ] ; then
      CMD_LINE=$(cat ${CMDLINE_TXT})
      if [[ ! $CMD_LINE =~ debug ]] ; then
        CMDLINE_TXT_BACKUP="${CMDLINE_TXT}.$(date +%Y%m%d-%H-%M-%S)"
        inform "created backup of ${CMDLINE_TXT} in ${CMDLINE_TXT_BACKUP}"
        cp ${CMDLINE_TXT}  ${CMDLINE_TXT_BACKUP}
      	CMD_LINE="${CMD_LINE} debug"
      	echo $CMD_LINE > ${CMDLINE_TXT}
      fi
    fi
  else
      inform "boot setup is disabled, NO_SETUP=$NO_SETUP"
  fi
}

function undoBootCfg_rpi {
  if [ "$RESTORE_BOOT" == "TRUE" ] ; then
    if [ -n "$CONFIG_TXT_BACKUP" ] && [ -f "$CONFIG_TXT_BACKUP" ] ; then
      cp $CONFIG_TXT_BACKUP $CONFIG_TXT
    fi

    if [ -n "$CMDLINE_TXT_BACKUP" ] && [ -f "$CMDLINE_TXT_BACKUP" ] ; then
      cp $CMDLINE_TXT_BACKUP $CMDLINE_TXT
    fi
    RESTORE_BOOT=
  fi
}


####################################################
## setup beaglebone device to boot with initramfs
####################################################

function setupBootCfg_bb {
  fail "setupBootCfg_bb not implemented"
  # modify bbb_uEnv.txt ?
}

function undoBootCfg_bb {
  fail "undoBootCfg_bb not implemented"
  # modify bbb_uEnv.txt ?
}

####################################################
## setup intel device to boot with initramfs
####################################################

function setupBootCfg_other {
  inform "setupBootCfg_other"
  # TODO: grub boot device is set in $GRUB_BOOT_DEV - try to determine it from setup (eg. grub.conf)
  # TODO: assuming we are on debian like OS

  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} grub-install busybox"

  # make sure BUSYBOX is used & **most** modules are present
  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1y/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"
  sed -i 's/^\(MODULES\s*=\s*\).*$/\1most/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"

  # check if this is an uefi booted system
  local efiBootMgr=$(whereis -b efibootmgr | awk '{ print $2}')
  if [ -n "$efiBootMgr" ] &&  efibootmgr &>/dev/null ; then
    GRUB_BOOT_TYPE="UEFI"
    INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} efibootmgr" # TODO: might or might not be using it
  fi

  local KERNEL_CMD_LINE_RAW=$(cat /proc/cmdline)
  if [ -z "$KERNEL_CMD_LINE_RAW" ] ; then
    fail "no kernel command line found"
  fi

  case "$KERNEL_CMD_LINE_RAW" in
     BOOT_IMAGE=*)
        # Ubuntu version
        local KERNEL_CMD_LINE=$(expr match "$KERNEL_CMD_LINE_RAW" '^BOOT_IMAGE=\(.*\)')
        # local KERNEL_CMD_LINE="vmlinuz-4.4.0-31-generic root=UUID=1bddfe9b-69cd-499d-bd21-2639700a899e ro"
        local TMP=($KERNEL_CMD_LINE)

        #KBOOT_DIR=$(dirname ${TMP[0]})
        #if [ "$KBOOT_DIR" != "/boot" ] ; then
        #   # boot config does not appear to be on root partition
        #  if [ "$KBOOT_DIR" == "." ] ; then
        #    $KBOOT_DIR=
        #  else
        #     $KBOOT_DIR="$KBOOT_DIR/"
        #  fi
        #else
        #  KBOOT_DIR="${KBOOT_DIR}/"
        #fi
        ;;
        *)
          fail "not a known command line format $KERNEL_CMD_LINE_RAW"
        ;;
  esac

  if [[ ! "$KERNEL_CMD_LINE" =~ boot= ]] ; then
    KERNEL_CMD_LINE="$KERNEL_CMD_LINE boot=local"
  fi

  if [ "$DEBUG" == "TRUE" ] ; then
    if [[ ! "$KERNEL_CMD_LINE" =~ debug ]] ; then
      KERNEL_CMD_LINE="$KERNEL_CMD_LINE debug"
    fi
  fi

  inform "KERNEL_CMD_LINE=$KERNEL_CMD_LINE"
  # inform "BOOT_DIR=$BOOT_DIR"

  if [ -z "$(whereis -b update-grub)" ] || [ -z "$(whereis -b grub-reboot)" ] ; then
      fail "failed to ensure required programs update-grub, grub-reboot"
  fi

  if [ ! -d /etc/grub.d ] ; then
      fail "grub configuration not found"
  fi

# TODO: make grub HD num from hdDev, just assuming 0 for now

  GRUB_INSTALL="TRUE"

  cat << EOI > ${HOME_DIR}/grub.cfg
serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1
default=boot
timeout=0

menuentry 'boot'{
linux /vmlinuz root=LABEL=resin-rootA rootwait quiet loglevel=0 splash udev.log-priority=3 vt.global_cursor_default=0 intel_idle.max_cstate=1
}
EOI

  local grubDev=$(expr match "$GRUB_BOOT_DEV" '^\([^,]\+\),.*')
  echo "(${grubDev}) $BOOT_DEV" > ${HOME_DIR}/device.map

  if [ ! "$NO_SETUP" == "TRUE" ] ; then
    local blkId=$(whereis -b blkid | awk '{ print $2}')
    if [ -n "$blkId" ] ; then
      while read line ;
      do
        local discId=$line
        break
      done < <($blkId $ROOT_FS -o value)
      if [ -n "$discId" ] ; then
        local setRoot="search --no-floppy --fs-uuid --set=root $discId"
      fi
    fi

    if [ "$GPT_TABLE" == "TRUE" ] ; then
      local partMod="part_gpt"
      GRUB_BOOT_DEV="${GRUB_BOOT_DEV},gpt${ROOT_PART_NO}"
    else
      local partMod="part_msdos"
      GRUB_BOOT_DEV="${GRUB_BOOT_DEV},msdos${ROOT_PART_NO}"
    fi

    if [ -z "$setRoot" ] ; then
      local setRoot="set root='$GRUB_BOOT_DEV'"
    fi

    cat <<EOI > /etc/grub.d/42_resin
#!/bin/sh
exec tail -n +3 \$0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.

menuentry "resin-migration" {
  insmod $partMod
  insmod ext2

  $setRoot
  linux $KERNEL_CMD_LINE
  initrd  ${BOOT_DIR}/${INITRAMFS_NAME}
}
EOI
    chmod +x /etc/grub.d/42_resin

    inform "updating grub config using update-grub"
    update-grub || fail "failed to update grub config"
    inform "calling grub-reboot resin-migration"
    grub-reboot resin-migration
else
    inform "boot setup is disabled, NO_SETUP=$NO_SETUP"
fi
}

function undoBootCfg_other {
  if [ "$NO_SETUP" !=  "TRUE" ] && [ -f "/etc/grub.d/42_resin" ] ; then
    inform "undoing grub boot configuration"
    rm /etc/grub.d/42_resin || fail "failed to delete /etc/grub.d/42_resin"
    inform "updating grub config using update-grub"
    update-grub || fail "failed to update grub config"
  fi
}

####################################################################################
####################################################################################
# main : create initramfs & install it
####################################################################################
####################################################################################

if [[ $EUID -ne 0 ]]; then
    fail "This script must be run as root"
fi

if [ -f /etc/balena-migrate.conf ] ; then
  # override some of the settings above
  . /etc/balena-migrate.conf
fi

# name of initramfs to be created/used expected in $HOMEDIR
INITRAMFS_NAME="balena-migrate-initramfs-$(uname -r)"
MEM_MIN_FREE=67108864   # 64 MB
# raspi config.txt to modify
CONFIG_TXT="/boot/config.txt"
# raspi cmdline.txt to modify
CMDLINE_TXT="/boot/cmdline.txt"
SUPPORTED_OSSES="ubuntu-18.04 ubuntu-14.04 raspbian-9 debian-9"
SUPPORTED_ARCHS="x86_64 armv7l i686"

RASPI_1_REVS="0002 0003 0004 0005 0006 0007 0008 0009 000d 000e 000f 0010 0011 0012 0013 0014 0015 900092 900093	920093 9000c1 900021 900032 900092 900093 920093 9000c1"
RASPI_2_REVS="a01040 a01041 a21041 a22042"
RASPI_3_REVS="a02082 a020a0 a22082 a32082 a020d3"

ERROR_EXIT="reboot -f"
GRUB_MIN_VER=2
BOOT_DIR=/boot
# script namme for logging
SCRIPT_NAME="balena-stage1"
# where the migrate conf is created - DO NOT MODIFY hardcoded in initramfs scripts
MIGRATE_CONF=/etc/balena-migrate-stage2.conf

inform "establishing required programs"

# TODO: Check / install tools needed for initramfs too

INITRAM_REQUIRED_PGMS="dd df dirname echo expr grep gzip lsblk mkdir parted partprobe reboot sync stat touch udevadm"
REQUIRED_PGMS="awk findmnt lsblk mkinitramfs parted readlink sed"
checkPgms $REQUIRED_PGMS

inform "checked required programs"

inform "checking required files"
if [[ ! $HOME_DIR =~ ^/.* ]] ; then
  CURR_DIR=$(pwd)
  cd $HOME_DIR || fail "invalid/non existant HOME_DIR: $HOME_DIR"
  HOME_DIR=$(pwd)
  cd $CURR_DIR
fi

if [ ! -d "$HOME_DIR" ] ; then
  fail "homedir does not exist: $HOME_DIR"
fi

inform "HOME_DIR=$HOME_DIR"

if [ -z "$IMAGE_NAME" ] || [ ! -f "${HOME_DIR}/$IMAGE_NAME" ] ; then
  fail "missing image file: $IMAGE_NAME"
fi

##########################################
# detect device / check for correct image ?
##########################################

ARCH=$(uname -m)

if [ ! "$(listContains "$SUPPORTED_ARCHS" $ARCH)" == "TRUE" ] ; then
  fail "not a supported architecture: $ARCH"
fi

case $ARCH in
  armv*)
    checkArmDevs
    ;;
  x86_64)
    inform "ARCH=$ARCH"
    devType="x86_64"
    if [[ ! $IMAGE_NAME =~ genericx86-64 ]] ; then
        fail "expected genericx86-64 image, got $IMAGE_NAME"
    fi
    ;;
  i686)
    devType="i686"
    inform "ARCH=$ARCH"
    if [[ ! $IMAGE_NAME =~ intel-core2-32 ]] ; then
        fail "expected intel-core2-32 image, got $IMAGE_NAME"
    fi
    ;;
  *)
    fail "unknown / unsupported architecture: $ARCH"
    ;;
esac

checkPgms $INITRAM_REQUIRED_PGMS

KERNEL_VER=$(uname -r)
inform "KERNEL_VER=$KERNEL_VER"

OS_VERSION=$(checkOs)
inform "OS_VERSION=$OS_VERSION"

RES=$(listContains "${SUPPORTED_OSSES}" ${OS_VERSION})
# inform "listContains \"${SUPPORTED_OSSES}\" ${OS_VERSION} = <${RES}>"
if [ "$RES" != "TRUE" ] ; then
    fail "not a supported OS ${OS_VERSION}"
fi

if [ "$MK_INITRAMFS" == "TRUE" ] && [ ! -d "${HOME_DIR}/initramfs-tools" ] ; then
  fail "missing image directory: ${HOME_DIR}/initramfs-tools"
fi

getBootInfo

inform "root partition: ${ROOT_FS} boot partition: ${BOOT_FS} EFI partition: ${EFI_FS}"

TMP=($(splitPartName ${BOOT_FS}))

BOOT_PAD=${TMP[3]}
BOOT_DEV=${TMP[0]}/${TMP[1]}
BOOT_PART_NO=${TMP[2]}

TMP=($(splitPartName ${ROOT_FS}))
ROOT_PART_NO=${TMP[2]}

if [ "$BOOT_DEV" != "${TMP[0]}/${TMP[1]}" ] ; then
  fail "unsupported boot configuration /boot is on a separate drive from / "
fi

while read line ;
do
  # inform "parted line: $line"

  if [[ $line =~ ^Partition\ Table:\ gpt ]] ; then
    inform "gpt partition table found"
    GPT_TABLE="TRUE"
    continue
  fi

  # determine BOOT partitions FS type
  if [[ $line =~ ^${BOOT_PART_NO}.* ]] ; then
    parts=($line)
    if [ "$GPT_TABLE" == "TRUE" ] ; then
      BOOT_FS_TYPE=${parts[4]}
    else
      BOOT_FS_TYPE=${parts[5]}
    fi

    if [[ $BOOT_FS_TYPE =~ ^fat[0-9]+$ ]]  ; then
      BOOT_FS_TYPE="vfat"
    fi
    break
  fi
done < <(parted -s ${BOOT_DEV} print)

inform "ROOT_DEV=${BOOT_DEV}, FS type: $BOOT_FS_TYPE"

###########################
## create boot configuration
###########################

case "$devType" in
    armv7_rpi*)
      inform "performing boot setup for RPI: $devType"
      setupBootCfg_rpi
    ;;
    armv7_bb*)
      inform "performing boot setup for Beaglebone: $devType"
      setupBootCfg_bb
    ;;
    *)
      inform "performing boot setup for other: $devType"
      setupBootCfg_other
    ;;
esac

###########################
## write /etc/migrate.conf
###########################


cat <<EOI > ${MIGRATE_CONF}
#!/bin/sh
# DO NOT EDIT ! This file is supposed to be created by stage1 script

REQUIRED_PGMS="$INITRAM_REQUIRED_PGMS"
LOG_DRIVE=${LOG_DRIVE}
LOG_FS_TYPE=${LOG_FS_TYPE}
LOG_MOUNT_DIR=/extlog
LOG_FILE=migrate.log

STRATEGY=${STRATEGY}
BOOT_DEV=${BOOT_DEV}

RESTORE_BOOT=$RESTORE_BOOT
REMOUNT_BOOT=$REMOUNT_BOOT
ORIG_BOOT_PART=${BOOT_FS}
ORIG_ROOT_PART=${ROOT_FS}
ORIG_BOOT_FS_TYPE=${BOOT_FS_TYPE}

HOME_DIR=${HOME_DIR}
IMAGE_FILE=${IMAGE_NAME}
BACKUP_FILE=${BACKUP_FILE}

MIGRATE_TMP=/balena-migrate

BOOT_MNT_DIR=/resin-boot
BOOT_PART_NAME=${BOOT_DEV}${BOOT_PAD}1
BOOT_PART_TYPE=vfat

DATA_MNT_DIR=/resin-data
DATA_PART_NAME=${BOOT_DEV}${BOOT_PAD}6
DATA_PART_TYPE=ext4

NO_FLASH=${NO_FLASH}
ERROR_EXIT="${ERROR_EXIT}"
TERM_EXIT="${TERM_EXIT}"

GRUB_INSTALL=${GRUB_INSTALL}
GRUB_BOOT_TYPE=${GRUB_BOOT_TYPE}
GRUB_PART_GPT=${GPT_TABLE}

BALENA_CONFIG="${BALENA_CONFIG}"
MEM_MIN_FREE=$MEM_MIN_FREE

EOI

if [ -n "$CONFIG_TXT_BACKUP" ] ; then
  cat <<EOI >> ${MIGRATE_CONF}
CONFIG_TXT=$(basename $CONFIG_TXT)
CONFIG_TXT_BACKUP=$(basename ${CONFIG_TXT_BACKUP})

EOI
fi

if [ -n "$CMDLINE_TXT_BACKUP" ] ; then
  cat <<EOI >> ${MIGRATE_CONF}
CMDLINE_TXT=$(basename $CMDLINE_TXT)
CMDLINE_TXT_BACKUP=$(basename ${CMDLINE_TXT_BACKUP})

EOI
fi

#####################################
## USE: resize strategy - unfinished
#####################################

if [ "$STRATEGY" == "RESIZE" ] ; then
  cat <<EOI >> ${MIGRATE_CONF}
MEM_MIN_AVAIL=600000
MEM_TMPFS_SIZE=512M
RESIZE_FS="${ROOT_FS}"
RESIZE_DEV=${BOOT_DEV}
RESIZE_PART_NO=${TMP[2]}
# TODO: actually calculate this
RESIZE_PART_START=94208
RESIZE_PART_END=31116287
RESIZE_PART_TYPE=primary
RESIZE_PART_FS=ext4
RESIZE_PART_TO=26921984
RESIZE_PART_SIZE=26827777

NEW_PART_TYPE="primary"
NEW_PART_FS="ext2"
NEW_PART_START=26926080
NEW_PART_TO=31022087
NEW_PART_NAME=/dev/mmcblk0p3
REQUIRED_PGMS="$INITRAM_REQUIRED_PGMS"
EOI
fi

###########################
## migrate network config
###########################

NETWORK_CONFIGS=

if [ -n "$BALENA_CONFIG" ] && [ -f "${HOME_DIR}/${BALENA_CONFIG}" ] && [ "$BALENA_WIFI" == "TRUE" ] ; then
  inform "scanning ${HOME_DIR}/${BALENA_CONFIG} for wifi"
  while read line ;
  do
    if [[ $line =~ ,*[\ ]*\"wifiSsid\"[\ ]*\: ]] ; then
      wifiSsid=$(expr match "$line" '.*"wifiSsid"[ ]*:[ ]*"\([^"]\+\)".*')
    fi

    if [[ $line =~ ,*[\ ]*\"wifiKey\"[\ ]*\: ]] ; then
      wifiKey=$(expr match "$line" '.*"wifiKey"[ ]*:[ ]*"\([^"]\+\)".*')
    fi
  done < "${HOME_DIR}/${BALENA_CONFIG}"

  if [ -n "$wifiSsid" ] ; then
    inform "creating config for wifi $wifiSsid"
    create_nmgr_file 1 $wifiSsid $wifiKey
    HAS_WIFI_CFG="TRUE"
  fi
fi

if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] || [ -n "$MIGRATE_WIFI_CFG" ] ; then
  if [ -f /etc/wpa_supplicant/wpa_supplicant.conf ] ; then
    wificfg_from_wpa
  else
    if [ -d /etc/NetworkManager/system-connections/ ] ; then
      wificfg_from_nmgr
    else
      warn "no supported wifi config found"
    fi
  fi

  if [ -n "$NETWORK_CONFIGS" ] ; then
    echo "NETWORK_CONFIGS=\"$NETWORK_CONFIGS\"" >> ${MIGRATE_CONF}
    echo "" >> ${MIGRATE_CONF}
  fi
fi

###########################
## create initramfs
###########################

if [ "${MK_INITRAMFS}" == TRUE ] ; then
    OPTS="-d ${HOME_DIR}/initramfs-tools -o ${HOME_DIR}/${INITRAMFS_NAME}"
    if [ "$MK_INITRAM_VERBOSE" == "TRUE" ] ; then
      OPTS="-v $OPTS"
    fi

    if [ "$MK_INITRAM_RETAIN" == "TRUE" ] ; then
      OPTS="-k $OPTS"
    fi

    inform "creating initramfs: mkinitramfs $OPTS"
    if ! mkinitramfs $OPTS ; then
      inform "failed to create initramfs in ${HOME_DIR}/${INITRAMFS_NAME} , attempting to undo boot setup"
      case "$devType" in
          armv7_rpi*)
            inform "undoing boot setup for RPI: $devType"
            undoBootCfg_rpi
          ;;
          armv7_bb*)
            inform "undoing boot setup for Beaglebone: $devType"
            undoBootCfg_bb
          ;;
          *)
            inform "undoing boot setup for other: $devType"
            undoBootCfg_other
          ;;
      esac
      fail "failed to create initramfs in ${HOME_DIR}/${INITRAMFS_NAME}"
    fi

    inform "copying ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"
    cp ${HOME_DIR}/${INITRAMFS_NAME} "${BOOT_DIR}/" || fail "failed to copy ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"
fi

###########################
## create backup
###########################

if [ -n "$BACKUP_DIRECTORIES" ] ; then
  inform "creating backup in ${HOME_DIR}/$BACKUP_FILE"
  if [ -f "${HOME_DIR}/$BACKUP_FILE" ] ; then
    rm ${HOME_DIR}/$BACKUP_FILE || true
  fi

  tar -czf ${HOME_DIR}/$BACKUP_FILE $BACKUP_DIRECTORIES
  inform "done creating backup"
  # TODO: check / restrict size of backup file
fi

###########################
## check memory
###########################

#spaceReq=$(stat --format=%s ${HOME_DIR}/${INITRAMFS_NAME})
#if [ -f "${HOME_DIR}/${BACKUP_FILE}" ] ; then
#  tmp=$(stat --format=%s ${HOME_DIR}/${BACKUP_FILE})
#  spaceReq=$(($spaceReq + $tmp))
#fi

#while read line ;
#do
#  if [[ $line =~ ^Mem:.* ]] ; then
#    totMem=$(expr match "$line" 'Mem:[ ]\+\([^ ]\+\).*')
#    inform "readin line $line, totMem: $totMem"
#  fi
#done < <(free -b)


###########################
## reboot
###########################

if [ "$DO_REBOOT" == "TRUE" ] ; then
  inform "rebooting system in 5 seconds"
  sleep 5
  reboot
fi
