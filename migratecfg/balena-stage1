#!/bin/bash
####################################################################
# balena-stage1
# setup migration for brown-field device to balena
####################################################################

####################################################################
# TODO: parted not installed on default beaglebone debian install,
#       install or replace
# TODO: remove non DEFAULT strategies ?
####################################################################


################################################################################
################################################################################
# All of the following variables can be overridden in /etc/balena-migrate.conf
################################################################################
################################################################################

################################################################################
# attempt to mount and log initramfs logs to external drive if set
LOG_DRIVE=/dev/sdb1
LOG_FS_TYPE=ext4

################################################################################
# where everything is
# TODO: establish & use an absolute path to a set home directory that is not
#       necessarily PWD
HOME_DIR=./

################################################################################
# reboot automatically after script has finished by setting to "TRUE"
DO_REBOOT= # "TRUE"

################################################################################
# name of the balenaOS image to flash (expected in $HOMEDIR)
# must be set in /etc/balena-migrate.conf
# IMAGE_NAME="resin-image-genericx86-64.resinos-img.gz"
# IMAGE_NAME="resin-resintest-raspberrypi3-2.15.1+rev2-dev-v7.16.6.img.gz"

################################################################################
# Use wifi config provided in image if set to TRUE
HAS_WIFI_CFG="FALSE" # set to "TRUE" if a wifi config is provided in image

################################################################################
# create NM configs from all configs found in this system
MIGRATE_ALL_WIFIS="FALSE" # migrate all wifis if set to "TRUE"

################################################################################
# only create NM wifi configs for ssids listed in this file
# file with a list of wifi networks to migrate, one per line
MIGRATE_WIFI_CFG="migrate-wifis"

################################################################################
# inject the config.json provided under the given filename into resin-boot
# set to the path of a config.json file to copy to the image
BALENA_CONFIG=

################################################################################
# if set to TRUE attempt to extract a wifi config from config.json given in
# BALENA_CONFIG
BALENA_WIFI=

################################################################################
# switch on initramfs / kernel debug mode by seting to "TRUE"
DEBUG= # "TRUE"

################################################################################
# name of backup file to create/transfer to balena-data
BACKUP_FILE=backup.tgz

################################################################################
# TODO: customer defined backup script to call
BACKUP_SCRIPT=

################################################################################
# arguments to tar -czf $BACKUP_FILE if no backup script is given
BACKUP_DIRECTORIES="/etc"

################################################################################
# Grub boot device in grub notation - usually not nee
GRUB_BOOT_DEV="hd0"

################################################################################
# minimum free memory in stage 2
# stage 2 script reads free memory
#   subtracts size of image file & backup files
#   fails if remaining space is less than the value given in MEM_MIN_FREE
MEM_MIN_FREE_S2=65536   # 64 MB as kB

################################################################################
# minimum free memory in stage 1
# stage 1 script reads total memory
#   subtracts size of image file & backup files & initramfs
#   fails if remaining space is less than the value given in MEM_MIN_FREE
MEM_MIN_FREE_S1=65536   # 64 MB as kB

################################################################################
# DEBUG end initramfs scripts before unmounting root / flashing the image
NO_FLASH= #"TRUE"

################################################################################
# DEBUG: do not modify config.txt, cmdline.txt, grub config if set to "TRUE"
NO_SETUP= #{ }"TRUE"

################################################################################
# create initramfs in contrast to using an initramfs supplied
MK_INITRAMFS="TRUE"

################################################################################
# DEBUG verbose build process
MK_INITRAM_VERBOSE= # "TRUE"

################################################################################
# DEBUG keep initramfs layout
MK_INITRAM_RETAIN= # "TRUE"

################################################################################
# DEBUG enable DEBUG messages if set to TRUE
LOG_DEBUG= # "TRUE"

##########################################
# log functions
##########################################

function inform {
    echo "[$(date +%T) ${SCRIPT_NAME}] INFO: $1"
}

function warn {
    echo "[$(date +%T) ${SCRIPT_NAME}] WARN: $1"
}

function debug {
    if [ "$LOG_DEBUG" == "TRUE" ] && listContains "$DEBUG_FUNCTS" $1 ; then
      echo "[$(date +%T) ${SCRIPT_NAME}] DEBUG: ${1}: ${2}"
    fi
}

function simulate {
    echo "[$(date +%T) ${SCRIPT_NAME}] INFO: would execute \"$*\""
}

function clean {
    if [ -n "${CONFIG_TXT_BACKUP}" ] ; then
        cp ${CONFIG_TXT_BACKUP} ${CONFIG_TXT}
    fi
}

##########################################
# fail : try to resotore & reboot
##########################################

function fail {
    echo "[$(date +%T) ${SCRIPT_NAME}] ERROR: $1"
    clean
    exit -1
}

##########################################
# check if list contains string
##########################################
# careful how you call it, should be
# eg.: listContains "$SUPPORTED_OSTYPES" $OSTYPE
function listContains {
    for curr in $1
    do
        if [ "$2" == "$curr" ]; then
            return 0
        fi
    done
    return 1
}

##########################################
# check if programs are available
##########################################

function checkPgms {
  for pgm in $*
  do
      local pgmPath="$(whereis -b $pgm | awk '{ print $2}')"
      if [ -z "$pgmPath" ] || [ ! -f "$pgmPath" ] ; then
        fail "cannot find required program: $pgm as $pgmPath"
     fi
  done
}


##########################################
# try to establish OS release
##########################################
checkOs() {
    if [ -f /etc/os-release ]; then
        local OS_ID=$(grep -e ^ID= /etc/os-release | sed "s/^ID=\(.*\)$/\1/")
        local OS_VERSION=$(grep -e ^VERSION_ID= /etc/os-release | sed -n 's/^VERSION_ID="\?\([^"]*\)"\?$/\1/p')
        VERSION="$OS_ID-$OS_VERSION"
    else
        # other methods for other osses
        # hostnamectrl
        # lsb_release -a
        # add methods as you add osses that need different methods from above
        VERSION=
        fail "unable to retrieve OS version"
    fi
    echo "$VERSION"
}

##########################################
# create a network manager wifi file
##########################################

function create_nmgr_file {
  local WIFI_NO=$1
  local WIFI_SSID=$2
  local WIFI_PSK=$3
  local FILE_NAME="resin-wifi-`printf %02d $WIFI_NO`"

  cat << EOI > ${FILE_NAME}
  [connection]
  id=$FILE_NAME
  type=wifi

  [wifi]
  hidden=true
  mode=infrastructure
  ssid=${WIFI_SSID}

  [wifi-security]
  auth-alg=open
  key-mgmt=wpa-psk
  psk=${WIFI_PSK}

  [ipv4]
  method=auto

  [ipv6]
  addr-gen-mode=stable-privacy
  method=auto
EOI
if [ -z "$NETWORK_CONFIGS" ] ; then
  NETWORK_CONFIGS="$FILE_NAME"
else
  NETWORK_CONFIGS="$NETWORK_CONFIGS $FILE_NAME"
fi
}

####################################################################################
# wether to migrate a ssid
####################################################################################

function migrate_this_wifi {
  local ssid="$*"
  debug "migrate_this_wifi" "ssid=<${ssid}> MIGRATE_ALL_WIFIS=${MIGRATE_ALL_WIFIS} MIGRATE_WIFI_CFG=${MIGRATE_WIFI_CFG} "
  if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] ; then
    debug "migrate_this_wifi" "migrate ALL, return 0"
    return 0
  else
      if [ -n "$MIGRATE_WIFI_CFG" ] && [ -f "${HOME_DIR}/${MIGRATE_WIFI_CFG}" ] ; then
          # debug "migrate_this_wifi: looking at ${HOME_DIR}/${MIGRATE_WIFI_CFG}"
          while read line
          do
            # debug "migrate_this_wifi: compare to: <$line>"
            if [ "$line" == "$ssid" ] ; then
              debug "migrate_this_wifi" "wifi found in ${HOME_DIR}/${MIGRATE_WIFI_CFG}, return 0"
              return 0
            fi
          done < "${HOME_DIR}/${MIGRATE_WIFI_CFG}"
      fi
  fi
  debug "migrate_this_wifi" " wifi not found, return 1"
  return 1
}

####################################################################################
# extract wifi network config from wpa_supplicant.conf
####################################################################################

function wificfg_from_wpa {
  local cfgNo=1

  if [ "$HAS_WIFI_CFG" == "TRUE" ] ; then
    cfgNo=2
  fi

  debug "wificfg_from_wpa" "cfgNo=${cfgNo} file=${WPA_SUPP_CONF}"

  while read line ;
  do
    if [[ $line =~ ^\s*network\s*=\s*\{ ]] ; then
      local network="TRUE"
      local ssid=
      local psk=
    else
      if [ "$network" == "TRUE" ] ; then
        if [[ $line =~ ^\s*} ]] ; then
          if [ -n "$ssid" ]  ; then
              debug "wificfg_from_wpa" "create_nmgr_file $cfgNo $ssid $psk"
              create_nmgr_file $cfgNo "$ssid" "$psk"
              cfgNo=$((cfgNo + 1))
              ssid=
              psk=
              network=
          fi
          continue
        fi

        if [[ $line =~ ^\s*ssid\s*= ]] ; then

          local tmpSsid=$(expr match "$line" '\s*ssid\s*=\s*"\([^"]\+\)"')

          if [ -z "$tmpSsid" ] ; then
            tmpSsid=$(expr match "$line" '\s*ssid\s*=\s*\(\S\+\)')
          fi

          if migrate_this_wifi $tmpSsid ; then
            ssid=${tmpSsid}
          fi
          continue
        fi

        if [[ $line =~ ^\s*psk\s*= ]] ; then
          # debug "wificfg_from_wpa" "psk in line : <${line}>"
          psk=$(expr match "$line" '\s*psk\s*=\s*"\([^"]\+\)"')
          if [ -z "$psk" ] ; then
            psk=$(expr match "$line" '\s*psk\s*=\s*\(\S\+\)')
          fi
          continue
        fi
      fi
    fi
  done < $WPA_SUPP_CONF
}

##########################################
# migrate/copy NetworkManager files
##########################################

function wificfg_from_nmgr {
  local cfgNo=1
  if [ "$HAS_WIFI_CFG" == "TRUE" ] ; then
    cfgNo=2
  fi

  debug "wificfg_from_nmgr" "cfgNo=${cfgNo}"

  for file in ${NMGR_DIR}/* ; do
    debug "wificfg_from_nmgr" "processing file: $file"

    local grepRes=$(grep -E "^\s*type\s*=\s*wifi" "$file")
    if [ -z "$grepRes" ] ; then
      continue
    fi
    grepRes=$(grep -E "^\s*ssid\s*=.*" "$file")
    local currSsid=$(expr match "$grepRes" 'ssid\s*=\s*\(.*\)')

    if  migrate_this_wifi $currSsid ; then
      inform "migrating wifi config for $currSsid"
      # TODO: only extract certain params or copy the whole thing ?
      local fileName="resin-wifi-`printf %02d $cfgNo`"
      cp "$file" "$fileName"
      cfgNo=$((cfgNo + 1))
    fi
  done
}

##########################################
# split partition name into parts
# /dev/nvme0n1p1 -> "/dev/ nvme0n1 1 p"
##########################################

function splitPartName {
    local partName=$1
    local pathName=$(dirname "${partName}")
    local tmpName1=$(lsblk -no kname ${partName})
    local tmpName2=$(readlink -f "/sys/class/block/${tmpName1}/..")
    local devName=$(basename "${tmpName2}")
    local tmp=${tmpName1:${#devName}}
    local pad=$(expr match "${tmp}" '\([^0-9]*\)[0-9]\+')
    local no=$(expr match "${tmp}" '[^0-9]*\([0-9]\+\)')
    echo "${pathName} ${devName} ${no} ${pad}"
}

##########################################
# get root info
# get info about the mount point and path
# to /root
##########################################
function getBootInfo {
  if [ ! -d /boot ] ; then
    fail "boot directory could not be found"
  fi

  ROOT_FS=$(findmnt --noheadings --canonicalize --output SOURCE /)
  if [ -z "$ROOT_FS" ] ; then
    fail "root mount point could not be found"
  fi

  BOOT_FS=$(findmnt --noheadings --canonicalize --output SOURCE /boot)

  if [ -z "$BOOT_FS" ] ; then
    BOOT_FS=$ROOT_FS
  fi

  EFI_FS=$(findmnt --noheadings --canonicalize --output SOURCE /boot/efi)
}


##########################################
# check armvX arch  device
##########################################

function checkArmDevs {
  # local sysName=$(expr match "$(uname -a)" '^Linux \([ ]\+\)')
  local sysName=$(expr match "$(uname -a)" '^Linux \([^ ]\+\)')
  inform "platform is <${sysName}>"

  case "$sysName" in
    raspberrypi)
      inform "detected raspberry PI"
      RPI_HW_REV=$(awk '/^Revision/ {sub("^1000", "", $3); print $3}' /proc/cpuinfo)
      inform "RPI_HW_REV=$RPI_HW_REV"
      if listContains "${RASPI_1_REVS}" ${RPI_HW_REV} ; then
        devType="armv7_rpi1"
        inform "device is a Raspberry PI 1"
        if [[ ! $IMAGE_NAME =~ raspberrypi1 ]] ; then
          fail "expected raspberrypi1 image, got $IMAGE_NAME"
        fi
      else
          if listContains "${RASPI_2_REVS}" ${RPI_HW_REV} ; then
            devType="armv7_rpi2"
            inform "device is a Raspberry PI 2"
            if [[ ! $IMAGE_NAME =~ raspberry-pi2 ]] ; then
              fail "expected raspberrypi2 image, got $IMAGE_NAME"
            fi
          else
            if listContains "${RASPI_3_REVS}" ${RPI_HW_REV} ; then
              devType="armv7_rpi1"
              inform "device is a Raspberry PI 3"
              if [[ ! $IMAGE_NAME =~ raspberrypi3 ]] ; then
                fail "expected raspberrypi3 image, got $IMAGE_NAME"
              fi
            else
              fail "no known PI revision found: $RPI_HW_REV"
            fi
          fi
      fi
    ;;
    beaglebone)
      # eg.: TI AM335x BeagleBone Green
      local tmp=$(cat /proc/device-tree/model)
      local variant=$(expr match "$tmp" '.* BeagleBone \([^ ]\+\)')

      inform "detected Beaglebone $variant device"

      case "$variant" in
        Green)
          if [[ ! $IMAGE_NAME =~ beaglebone-green ]] ; then
            fail "expected beaglebone-green image, got $IMAGE_NAME"
          fi
          devType="armv7_bb_green"
        ;;
        *)
          fail "not a supported Beaglebone variant: $variant"
        ;;
      esac
    ;;
    *)
      fail "unrecognized arm hardware platform: $sysName, 'uname -a' reports: $(uname -a)"
    ;;
  esac
}



####################################################
## setup raspbery pi to boot using initramfs
####################################################

function setupBootCfg_rpi {
  inform "setupBootCfg_rpi"
  ##########################
  ## Modify /boot/config.txt
  ##########################

  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} cp cat rm sleep"

  # make sure BUSYBOX is NOT used
  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1n/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"
  sed -i 's/^\(MODULES\s*=\s*\).*$/\1list/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"


  if [ "$NO_SETUP" != "TRUE" ] ; then
    RESTORE_BOOT="TRUE"

    CONFIG_TXT_BACKUP="${CONFIG_TXT}.$(date +%Y%m%d-%H-%M-%S)"
    cp ${CONFIG_TXT}  ${CONFIG_TXT_BACKUP}
    inform "created backup of ${CONFIG_TXT} in ${CONFIG_TXT_BACKUP}"

    TMP_FILE=$(mktemp)
    INITRAM_CMD="initramfs ${INITRAMFS_NAME} followkernel"


    while read -r line
    do
      if [[ $line =~ ^\s*\# ]] ; then
        echo $line >> $TMP_FILE
        continue
      fi

      if [[ $line =~ ^\s*initramfs ]] ; then
        if [ "$line" != "$INITRAM_CMD" ] ; then
          echo "# $line" >> $TMP_FILE
        fi
      else
        echo $line >> $TMP_FILE
      fi
    done < "${CONFIG_TXT}"
    echo $INITRAM_CMD >> $TMP_FILE
    cp $TMP_FILE $CONFIG_TXT
    rm $TMP_FILE

    ###########################
    ## Modify /boot/cmdline.txt
    ###########################

    if [ "$DEBUG" == "TRUE" ] ; then
      CMD_LINE=$(cat ${CMDLINE_TXT})
      if [[ ! $CMD_LINE =~ debug ]] ; then
        CMDLINE_TXT_BACKUP="${CMDLINE_TXT}.$(date +%Y%m%d-%H-%M-%S)"
        inform "created backup of ${CMDLINE_TXT} in ${CMDLINE_TXT_BACKUP}"
        cp ${CMDLINE_TXT}  ${CMDLINE_TXT_BACKUP}
      	CMD_LINE="${CMD_LINE} debug"
      	echo $CMD_LINE > ${CMDLINE_TXT}
      fi
    fi
  else
      inform "boot setup is disabled, NO_SETUP=$NO_SETUP"
  fi
}

function undoBootCfg_rpi {
  if [ "$RESTORE_BOOT" == "TRUE" ] ; then
    if [ -n "$CONFIG_TXT_BACKUP" ] && [ -f "$CONFIG_TXT_BACKUP" ] ; then
      cp $CONFIG_TXT_BACKUP $CONFIG_TXT
    fi

    if [ -n "$CMDLINE_TXT_BACKUP" ] && [ -f "$CMDLINE_TXT_BACKUP" ] ; then
      cp $CMDLINE_TXT_BACKUP $CMDLINE_TXT
    fi
    RESTORE_BOOT=
  fi
}


####################################################
## setup beaglebone device to boot with initramfs
####################################################

function setupBootCfg_bb {
  fail "setupBootCfg_bb not implemented"
  # modify bbb_uEnv.txt ?
}

function undoBootCfg_bb {
  fail "undoBootCfg_bb not implemented"
  # modify bbb_uEnv.txt ?
}

####################################################
## setup intel device to boot with initramfs
####################################################

function setupBootCfg_other {
  inform "setupBootCfg_other"
  # TODO: grub boot device is set in $GRUB_BOOT_DEV - try to determine it from setup (eg. grub.conf)
  # TODO: assuming we are on debian like OS

  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} grub-install busybox"

  # make sure BUSYBOX is used & **most** modules are present
  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1y/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"
  sed -i 's/^\(MODULES\s*=\s*\).*$/\1most/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"

  # check if this is an uefi booted system
  local efiBootMgr=$(whereis -b efibootmgr | awk '{ print $2}')
  if [ -n "$efiBootMgr" ] &&  efibootmgr &>/dev/null ; then
    GRUB_BOOT_TYPE="UEFI"
    INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} efibootmgr" # TODO: might or might not be using it
  fi

  local KERNEL_CMD_LINE_RAW=$(cat /proc/cmdline)
  if [ -z "$KERNEL_CMD_LINE_RAW" ] ; then
    fail "no kernel command line found"
  fi

  case "$KERNEL_CMD_LINE_RAW" in
     BOOT_IMAGE=*)
        # Ubuntu version
        local KERNEL_CMD_LINE=$(expr match "$KERNEL_CMD_LINE_RAW" '^BOOT_IMAGE=\(.*\)')
        # local KERNEL_CMD_LINE="vmlinuz-4.4.0-31-generic root=UUID=1bddfe9b-69cd-499d-bd21-2639700a899e ro"
        local TMP=($KERNEL_CMD_LINE)

        #KBOOT_DIR=$(dirname ${TMP[0]})
        #if [ "$KBOOT_DIR" != "/boot" ] ; then
        #   # boot config does not appear to be on root partition
        #  if [ "$KBOOT_DIR" == "." ] ; then
        #    $KBOOT_DIR=
        #  else
        #     $KBOOT_DIR="$KBOOT_DIR/"
        #  fi
        #else
        #  KBOOT_DIR="${KBOOT_DIR}/"
        #fi
        ;;
        *)
          fail "not a known command line format $KERNEL_CMD_LINE_RAW"
        ;;
  esac

  if [[ ! "$KERNEL_CMD_LINE" =~ boot= ]] ; then
    KERNEL_CMD_LINE="$KERNEL_CMD_LINE boot=local"
  fi

  if [ "$DEBUG" == "TRUE" ] ; then
    if [[ ! "$KERNEL_CMD_LINE" =~ debug ]] ; then
      KERNEL_CMD_LINE="$KERNEL_CMD_LINE debug"
    fi
  fi

  inform "KERNEL_CMD_LINE=$KERNEL_CMD_LINE"
  # inform "BOOT_DIR=$BOOT_DIR"

  if [ -z "$(whereis -b update-grub)" ] || [ -z "$(whereis -b grub-reboot)" ] ; then
      fail "failed to ensure required programs update-grub, grub-reboot"
  fi

  if [ ! -d /etc/grub.d ] ; then
      fail "grub configuration not found"
  fi

# TODO: make grub HD num from hdDev, just assuming 0 for now

  GRUB_INSTALL="TRUE"

  cat << EOI > ${HOME_DIR}/grub.cfg
serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1
default=boot
timeout=0

menuentry 'boot'{
linux /vmlinuz root=LABEL=resin-rootA rootwait quiet loglevel=0 splash udev.log-priority=3 vt.global_cursor_default=0 intel_idle.max_cstate=1
}
EOI


  if [ ! "$NO_SETUP" == "TRUE" ] ; then

    debug setupBootCfg_other "looking for boot device blkid"

    if [ -d /dev/disk/by-uuid ] ; then
      for fname in /dev/disk/by-uuid/* ; do
        debug setupBootCfg_other "looking at $fname"
        linkedFile=$(readlink ${fname})
        debug setupBootCfg_other "go <${linkedFile}>"
        if [ "$(basename $ROOT_FS)" == "$(basename $linkedFile)" ] ; then
          # debug setupBootCfg_other "found ${uuid} for ${ROOT_FS}"
          partId=$(basename "$fname")
          break
        fi
      done
    fi

    if [ -n "${partId}" ] ; then
      inform "found uuid: ${partId} for boot drive ${ROOT_FS}"
    fi

    if [ -n "$partId" ] ; then
      local setRoot="search --no-floppy --fs-uuid --set=root $partId"
    fi

    if [ "$GPT_TABLE" == "TRUE" ] ; then
      local partMod="part_gpt"
      if [ -z "$setRoot" ] ; then
        local setRoot="set root='${GRUB_BOOT_DEV},gpt${ROOT_PART_NO}'"
      fi
    else
      local partMod="part_msdos"
      if [ -z "$setRoot" ] ; then
        local setRoot="set root='${GRUB_BOOT_DEV},msdos${ROOT_PART_NO}'"
      fi
    fi

    inform "grub config, set root: $setRoot"

    cat <<EOI > /etc/grub.d/42_resin
#!/bin/sh
exec tail -n +3 \$0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.

menuentry "resin-migration" {
  insmod $partMod
  insmod ext2

  $setRoot
  linux $KERNEL_CMD_LINE
  initrd  ${BOOT_DIR}/${INITRAMFS_NAME}
}
EOI
    chmod +x /etc/grub.d/42_resin

    inform "updating grub config using update-grub"
    update-grub || fail "failed to update grub config"
    inform "calling grub-reboot resin-migration"
    grub-reboot resin-migration
else
    inform "boot setup is disabled, NO_SETUP=$NO_SETUP"
fi
}

function undoBootCfg_other {
  if [ "$NO_SETUP" !=  "TRUE" ] && [ -f "/etc/grub.d/42_resin" ] ; then
    inform "undoing grub boot configuration"
    rm /etc/grub.d/42_resin || fail "failed to delete /etc/grub.d/42_resin"
    inform "updating grub config using update-grub"
    update-grub || fail "failed to update grub config"
  fi
}

####################################################################################
####################################################################################
# main : create initramfs & install it
####################################################################################
####################################################################################

if [[ $EUID -ne 0 ]]; then
    fail "This script must be run as root"
fi

if [ -f /etc/balena-migrate.conf ] ; then
  # override some of the settings above
  . /etc/balena-migrate.conf
fi

# default grub config type
GRUB_BOOT_TYPE="legacy"

# name of initramfs to be created/used expected in $HOMEDIR
INITRAMFS_NAME="balena-migrate-initramfs-$(uname -r)"

# raspi config.txt to modify
CONFIG_TXT="/boot/config.txt"
# raspi cmdline.txt to modify
CMDLINE_TXT="/boot/cmdline.txt"
# supported / tested OSSE's so far
SUPPORTED_OSSES="ubuntu-18.04 ubuntu-14.04 raspbian-9 debian-9"
# supported / tested platforms so far
SUPPORTED_ARCHS="x86_64 armv7l i686"

# mappings of RPi rev numbers to device types
RASPI_1_REVS="0002 0003 0004 0005 0006 0007 0008 0009 000d 000e 000f 0010 0011 0012 0013 0014 0015 900092 900093	920093 9000c1 900021 900032 900092 900093 920093 9000c1"
RASPI_2_REVS="a01040 a01041 a21041 a22042"
RASPI_3_REVS="a02082 a020a0 a22082 a32082 a020d3"

# minimum supported grub version
GRUB_MIN_VER=2
# default boot directory
BOOT_DIR=/boot
# script namme for logging
SCRIPT_NAME="balena-stage1"
# where the migrate conf is created - DO NOT MODIFY hardcoded in initramfs scripts
MIGRATE_CONF=/etc/balena-migrate-stage2.conf

# DEBUG_FUNCTS="migrate_this_wifi wificfg_from_wpa"
DEBUG_FUNCTS= "main"

# WPA_SUPP_CONF="/etc/wpa_supplicant/wpa_supplicant.conf"
WPA_SUPP_CONF="/etc/wpa_supplicant/wpa_supplicant.conf"
NMGR_DIR="/etc/NetworkManager/system-connections"

inform "establishing required programs"

# TODO: Check / install tools needed for initramfs too
#       possible candidates: parted (on debian, beaglebone) blkid

INITRAM_REQUIRED_PGMS="cat dd df dirname echo expr grep gzip lsblk mkdir parted partprobe reboot sync stat touch udevadm"
REQUIRED_PGMS="awk findmnt lsblk mkinitramfs parted readlink sed"
checkPgms $REQUIRED_PGMS

inform "checked required programs"

inform "checking required files"
if [[ ! $HOME_DIR =~ ^/.* ]] ; then
  CURR_DIR=$(pwd)
  cd $HOME_DIR || fail "invalid/non existant HOME_DIR: $HOME_DIR"
  HOME_DIR=$(pwd)
  cd $CURR_DIR
fi

if [ ! -d "$HOME_DIR" ] ; then
  fail "homedir does not exist: $HOME_DIR"
fi

inform "HOME_DIR=$HOME_DIR"

if [ -z "$IMAGE_NAME" ] || [ ! -f "${HOME_DIR}/$IMAGE_NAME" ] ; then
  fail "missing image file: $IMAGE_NAME"
fi

##########################################
# detect device / check for correct image ?
##########################################

ARCH=$(uname -m)

if ! listContains "$SUPPORTED_ARCHS" $ARCH ; then
  fail "not a supported architecture: $ARCH"
fi

case $ARCH in
  armv*)
    checkArmDevs
    ;;
  x86_64)
    inform "ARCH=$ARCH"
    devType="x86_64"
    if [[ ! $IMAGE_NAME =~ genericx86-64 ]] ; then
        fail "expected genericx86-64 image, got $IMAGE_NAME"
    fi
    ;;
  i686)
    devType="i686"
    inform "ARCH=$ARCH"
    if [[ ! $IMAGE_NAME =~ intel-core2-32 ]] ; then
        fail "expected intel-core2-32 image, got $IMAGE_NAME"
    fi
    ;;
  *)
    fail "unknown / unsupported architecture: $ARCH"
    ;;
esac

checkPgms $INITRAM_REQUIRED_PGMS

KERNEL_VER=$(uname -r)
inform "KERNEL_VER=$KERNEL_VER"

OS_VERSION=$(checkOs)
inform "OS_VERSION=$OS_VERSION"

if ! listContains "${SUPPORTED_OSSES}" ${OS_VERSION} ; then
    fail "not a supported OS ${OS_VERSION}"
fi

if [ "$MK_INITRAMFS" == "TRUE" ] && [ ! -d "${HOME_DIR}/initramfs-tools" ] ; then
  fail "missing image directory: ${HOME_DIR}/initramfs-tools"
fi

getBootInfo

inform "root partition: ${ROOT_FS} boot partition: ${BOOT_FS} EFI partition: ${EFI_FS}"

TMP=($(splitPartName ${BOOT_FS}))

BOOT_PAD=${TMP[3]}
BOOT_DEV=${TMP[0]}/${TMP[1]}
BOOT_PART_NO=${TMP[2]}

TMP=($(splitPartName ${ROOT_FS}))
ROOT_PART_NO=${TMP[2]}

if [ "$BOOT_DEV" != "${TMP[0]}/${TMP[1]}" ] ; then
  fail "unsupported boot configuration /boot is on a separate drive from / "
fi

while read line ;
do
  # inform "parted line: $line"

  if [[ $line =~ ^Partition\ Table:\ gpt ]] ; then
    inform "gpt partition table found"
    GPT_TABLE="TRUE"
    continue
  fi

  # determine BOOT partitions FS type
  if [[ $line =~ ^${BOOT_PART_NO}.* ]] ; then
    parts=($line)
    if [ "$GPT_TABLE" == "TRUE" ] ; then
      BOOT_FS_TYPE=${parts[4]}
    else
      BOOT_FS_TYPE=${parts[5]}
    fi

    if [[ $BOOT_FS_TYPE =~ ^fat[0-9]+$ ]]  ; then
      BOOT_FS_TYPE="vfat"
    fi
    break
  fi
done < <(parted -s ${BOOT_DEV} print)

inform "ROOT_DEV=${BOOT_DEV}, FS type: $BOOT_FS_TYPE"

###########################
## create boot configuration
###########################

case "$devType" in
    armv7_rpi*)
      inform "performing boot setup for RPI: $devType"
      setupBootCfg_rpi
    ;;
    armv7_bb*)
      inform "performing boot setup for Beaglebone: $devType"
      setupBootCfg_bb
    ;;
    *)
      inform "performing boot setup for other: $devType"
      setupBootCfg_other
    ;;
esac

###########################
## migrate network config
###########################

NETWORK_CONFIGS=

if [ -n "$BALENA_CONFIG" ] && [ -f "${HOME_DIR}/${BALENA_CONFIG}" ] && [ "$BALENA_WIFI" == "TRUE" ] ; then
  inform "scanning ${HOME_DIR}/${BALENA_CONFIG} for wifi"
  while read line ;
  do
    if [[ $line =~ ,*[\ ]*\"wifiSsid\"[\ ]*\: ]] ; then
      wifiSsid=$(expr match "$line" '.*"wifiSsid"[ ]*:[ ]*"\([^"]\+\)".*')
    fi

    if [[ $line =~ ,*[\ ]*\"wifiKey\"[\ ]*\: ]] ; then
      wifiKey=$(expr match "$line" '.*"wifiKey"[ ]*:[ ]*"\([^"]\+\)".*')
    fi
  done < "${HOME_DIR}/${BALENA_CONFIG}"

  if [ -n "$wifiSsid" ] ; then
    inform "creating config for wifi $wifiSsid"
    create_nmgr_file 1 $wifiSsid $wifiKey
    HAS_WIFI_CFG="TRUE"
  fi
fi

if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] || [ -n "$MIGRATE_WIFI_CFG" ] ; then
  if [ -f "$WPA_SUPP_CONF" ] ; then
    wificfg_from_wpa
  else
    if [ -d "$NMGR_DIR" ] ; then
      wificfg_from_nmgr
    else
      warn "no supported wifi config found"
    fi
  fi

  if [ -n "$NETWORK_CONFIGS" ] ; then
    echo "NETWORK_CONFIGS=\"$NETWORK_CONFIGS\"" >> ${MIGRATE_CONF}
    echo "" >> ${MIGRATE_CONF}
  fi
fi


###########################
## write /etc/migrate.conf
###########################


cat <<EOI > ${MIGRATE_CONF}
#!/bin/sh
# DO NOT EDIT ! This file is supposed to be created by stage1 script

REQUIRED_PGMS="$INITRAM_REQUIRED_PGMS"
LOG_DRIVE=${LOG_DRIVE}
LOG_FS_TYPE=${LOG_FS_TYPE}
LOG_MOUNT_DIR=/extlog
LOG_FILE=migrate.log

BOOT_DEV=${BOOT_DEV}

RESTORE_BOOT=$RESTORE_BOOT
REMOUNT_BOOT=$REMOUNT_BOOT
ORIG_BOOT_PART=${BOOT_FS}
ORIG_ROOT_PART=${ROOT_FS}
ORIG_BOOT_FS_TYPE=${BOOT_FS_TYPE}

HOME_DIR=${HOME_DIR}
IMAGE_FILE=${IMAGE_NAME}
BACKUP_FILE=${BACKUP_FILE}

MIGRATE_TMP=/balena-migrate

BOOT_MNT_DIR=/resin-boot
BOOT_PART_NAME=${BOOT_DEV}${BOOT_PAD}1
BOOT_PART_TYPE=vfat

DATA_MNT_DIR=/resin-data
DATA_PART_NAME=${BOOT_DEV}${BOOT_PAD}6
DATA_PART_TYPE=ext4

NO_FLASH=${NO_FLASH}

TERM_EXIT="${TERM_EXIT}"

GRUB_INSTALL=${GRUB_INSTALL}
GRUB_BOOT_TYPE=${GRUB_BOOT_TYPE}
GRUB_PART_GPT=${GPT_TABLE}

BALENA_CONFIG="${BALENA_CONFIG}"
MEM_MIN_FREE=${MEM_MIN_FREE_S2}

NETWORK_CONFIGS="$NETWORK_CONFIGS"

EOI

if [ -n "$CONFIG_TXT_BACKUP" ] ; then
  cat <<EOI >> ${MIGRATE_CONF}
CONFIG_TXT=$(basename $CONFIG_TXT)
CONFIG_TXT_BACKUP=$(basename ${CONFIG_TXT_BACKUP})

EOI
fi

if [ -n "$CMDLINE_TXT_BACKUP" ] ; then
  cat <<EOI >> ${MIGRATE_CONF}
CMDLINE_TXT=$(basename $CMDLINE_TXT)
CMDLINE_TXT_BACKUP=$(basename ${CMDLINE_TXT_BACKUP})

EOI
fi


###########################
## create initramfs
###########################

if [ "${MK_INITRAMFS}" == TRUE ] ; then
    # set gzip compression
    sed -i 's/^\(COMPRESS\s*=\s*\).*$/\1gzip/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"

    OPTS="-d ${HOME_DIR}/initramfs-tools -o ${HOME_DIR}/${INITRAMFS_NAME}"
    if [ "$MK_INITRAM_VERBOSE" == "TRUE" ] ; then
      OPTS="-v $OPTS"
    fi

    if [ "$MK_INITRAM_RETAIN" == "TRUE" ] ; then
      OPTS="-k $OPTS"
    fi

    inform "creating initramfs: mkinitramfs $OPTS"
    if ! mkinitramfs $OPTS ; then
      inform "failed to create initramfs in ${HOME_DIR}/${INITRAMFS_NAME} , attempting to undo boot setup"
      case "$devType" in
          armv7_rpi*)
            inform "undoing boot setup for RPI: $devType"
            undoBootCfg_rpi
          ;;
          armv7_bb*)
            inform "undoing boot setup for Beaglebone: $devType"
            undoBootCfg_bb
          ;;
          *)
            inform "undoing boot setup for other: $devType"
            undoBootCfg_other
          ;;
      esac
      fail "failed to create initramfs in ${HOME_DIR}/${INITRAMFS_NAME}"
    fi

    inform "copying ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"
    cp ${HOME_DIR}/${INITRAMFS_NAME} "${BOOT_DIR}/" || fail "failed to copy ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"
fi

###########################
## create backup
###########################

if [ -n "$BACKUP_FILE" ] ; then
  if [ -n "$BACKUP_SCRIPT" ] && [ -f "${HOME_DIR}/${BACKUP_SCRIPT}" ] ; then
    inform "invoking backup script using: ${HOME_DIR}/${BACKUP_SCRIPT} ${HOME_DIR}/${BACKUP_FILE}"
    ${HOME_DIR}/${BACKUP_SCRIPT} ${HOME_DIR}/${BACKUP_FILE} || fail "backup script ${HOME_DIR}/${BACKUP_SCRIPT} returned error code"
    inform "...done"
  else
    if [ -n "$BACKUP_DIRECTORIES" ] ; then
      if [ -f "${HOME_DIR}/$BACKUP_FILE" ] ; then
        rm ${HOME_DIR}/$BACKUP_FILE || true
      fi
      inform "creating backup using tar -czf ${HOME_DIR}/$BACKUP_FILE $BACKUP_DIRECTORIES"
      tar -czf "${HOME_DIR}/$BACKUP_FILE" $BACKUP_DIRECTORIES > /dev/null || fail "failed to create backup using tar -czf ${HOME_DIR}/$BACKUP_FILE $BACKUP_DIRECTORIES"
      inform "...done"
    fi
  fi

  if [ ! -f ${HOME_DIR}/${BACKUP_FILE} ] ; then
    warn "no backup file created in: ${HOME_DIR}/${BACKUP_SCRIPT} ${HOME_DIR}/${BACKUP_FILE}"
  fi
fi

###########################
## check memory
###########################

totMem=`cat /proc/meminfo | grep "MemTotal:"`
totMem=`expr match "$totMem" '[^:]\+:[^0-9]\+\([0-9]\+\)[^0-9]*kB'` || true
inform "total memory:  ${totMem} kB"

leftMem=$totMem

if [ -f "${HOME_DIR}/${IMAGE_NAME}" ] ; then
  tmp=`stat -c %s "${HOME_DIR}/${IMAGE_NAME}"`
  tmp=`expr $tmp / 1024` || true
  inform "image file size: ${tmp} kB "
  leftMem=`expr ${leftMem} - ${tmp}`
fi

if [ -f "${HOME_DIR}/${BACKUP_FILE}" ] ; then
  tmp=`stat -c %s "${HOME_DIR}/${BACKUP_FILE}"`
  tmp=`expr $tmp / 1024` || true
  inform "backup file size: ${tmp} kB "
  leftMem=`expr ${leftMem} - ${tmp}`
fi


fType=$(file "${HOME_DIR}/${INITRAMFS_NAME}")
if [[ "$fType" =~ ^[^:]+:.*cpio\ archive.* ]] ; then
  tmp=`stat -c %s "${HOME_DIR}/${INITRAMFS_NAME}"`
else
  if [[ $fType =~ ^[^:]+:[\ ]*gzip.* ]] ; then
    while read line ;
    do
      if echo "$line" | grep "${INITRAMFS_NAME}" > /dev/null ; then
        tmp=$(expr match "$line" '[0-9]\+[ ]\+\([0-9]\+\) .*')
        break;
      fi
    done < <(gzip -l "${HOME_DIR}/${INITRAMFS_NAME}")
  else
    warn "unexpected initramfs format"
    tmp=`stat -c %s "${HOME_DIR}/${INITRAMFS_NAME}"`
  fi
fi

tmp=`expr $tmp / 1024` || true
inform "initramfs est. size: ${tmp} kB "
leftMem=`expr ${leftMem} - ${tmp}`

inform "Est. memory left: ${leftMem} kB "
if [ ${leftMem} -lt ${MEM_MIN_FREE_S1} ] ; then
  fail "Est. memory left is less than set threshold (${MEM_MIN_FREE_S1} kB), reduce backup size or threshold in MEM_MIN_FREE_S1"
fi

###########################
## reboot
###########################

if [ "$DO_REBOOT" == "TRUE" ] ; then
  inform "rebooting system in 5 seconds"
  sleep 5
  reboot
fi
