#!/bin/bash
####################################################################
# balena-stage1
# setup migration for brown-field device to balena
####################################################################

####################################################################
# TODO: parted not installed on default beaglebone debian install,
#       install or replace
# TODO: add -r --reboot cmdline parameters
# TODO: attempt to detect flasher images
#
####################################################################


################################################################################
################################################################################
# All of the following variables can be overridden in /etc/balena-migrate.conf
################################################################################
################################################################################

################################################################################
# attempt to mount and log initramfs logs to external drive if set
LOG_DRIVE= # /dev/sdb1
LOG_FS_TYPE=ext4

################################################################################
# where everything is
# TODO: establish & use an absolute path to a set home directory that is not
#       necessarily PWD
HOME_DIR=./

################################################################################
# reboot automatically after script has finished by setting to "TRUE"
DO_REBOOT= # "TRUE"

################################################################################
# name of the balenaOS image to flash (expected in $HOMEDIR)
# must be set in /etc/balena-migrate.conf
# IMAGE_NAME="resin-image-genericx86-64.resinos-img.gz"
# IMAGE_NAME="resin-resintest-raspberrypi3-2.15.1+rev2-dev-v7.16.6.img.gz"


################################################################################
# create NM configs from all configs found in this system
MIGRATE_ALL_WIFIS="FALSE" # migrate all wifis if set to "TRUE"

################################################################################
# only create NM wifi configs for ssids listed in this file
# file with a list of wifi networks to migrate, one per line
MIGRATE_WIFI_CFG="migrate-wifis"

################################################################################
# inject the config.json provided under the given filename into resin-boot
# set to the path of a config.json file to copy to the image
BALENA_CONFIG=

################################################################################
# if set to TRUE attempt to extract a wifi config from config.json given in
# BALENA_CONFIG
BALENA_WIFI=

################################################################################
# switch on initramfs / kernel debug mode by seting to "TRUE"
DEBUG= # "TRUE"

################################################################################
# customer defined backup script to call
BACKUP_SCRIPT=

################################################################################
# Backup definition file
BACKUP_DEFINITION=

################################################################################
# Grub boot device in grub notation - usually not nee
GRUB_BOOT_DEV="hd0"

################################################################################
# minimum free memory in stage 2
# stage 2 script reads free memory
#   subtracts size of image file & backup files
#   fails if remaining space is less than the value given in MEM_MIN_FREE
MEM_MIN_FREE_S2=65536   # 64 MB as kB

################################################################################
# minimum free memory in stage 1
# stage 1 script reads total memory
#   subtracts size of image file & backup files & initramfs
#   fails if remaining space is less than the value given in MEM_MIN_FREE
MEM_MIN_FREE_S1=65536   # 64 MB as kB

################################################################################
# DEBUG end initramfs scripts before unmounting root / flashing the image
NO_FLASH= #"TRUE"

################################################################################
# DEBUG: do not modify config.txt, cmdline.txt, grub config if set to "TRUE"
NO_SETUP= #{ }"TRUE"

################################################################################
# Test connectivity to API and VPN hosts"
BALENA_API_HOST="api.balena-cloud.com"
BALENA_API_PORT=443
BALENA_VPN_HOST="vpn.balena-cloud.com"
BALENA_VPN_PORT=443
BALENA_CONNECT_TIMEOUT=20

################################################################################
# Fail if no network manager file is created
REQUIRE_NMGR_FILE=TRUE

################################################################################
# DEBUG verbose build process
MK_INITRAM_VERBOSE= # "TRUE"

################################################################################
# DEBUG keep initramfs layout
MK_INITRAM_RETAIN= # "TRUE"

################################################################################
# Minimum required free diskspace in KB, default 10MB
MIN_ROOT_AVAIL=10240 

################################################################################
# DEBUG enable DEBUG messages if set to TRUE
LOG_DEBUG= #"TRUE"

##########################################
# log functions
##########################################

function color {
  if [ -n "$1" ] ; then
    YELLOW='\033[1;33m'
    BROWN='\033[0;33m'
    GREEN='\033[0;32m'
    RED='\033[0;31m'
    NC='\033[0m' # No Color
  else
    YELLOW=
    BROWN=
    GREEN=
    RED=
    NC=
  fi
}

function inform {
    printf "${GREEN}[%s %s] INFO:${NC} %s\n" "$(date +%T)" "${SCRIPT_NAME}" "${1}"
}

function warn {
    printf "${YELLOW}[%s %s] WARN:${NC} %s\n" "$(date +%T)" "${SCRIPT_NAME}" "${1}"
}

function debug {
    if [ "$LOG_DEBUG" == "TRUE" ] && listContains "$DEBUG_FUNCTS" "${1}" ; then
      printf "${BROWN}[%s %s] DEBUG:${NC} %s: %s\n" "$(date +%T)" "${SCRIPT_NAME}" "${1}" "${2}"
    fi
}

function simulate {
    printf "${GREEN}[%s %s] INFO:${NC}  %s\n" "$(date +%T)" "${SCRIPT_NAME}" "${1}"
}

function clean {
    if [ -n "$TMP_DIR" ] && [ -d "$TMP_DIR" ] ; then
      debug clean "removing $TMP_DIR"
      rm -rf "$TMP_DIR"
    fi

    if [ -n "$RESTORE_BOOT_CFG_STAGE1" ] ; then
      debug clean "attempting <sh -c ${RESTORE_BOOT_CFG_STAGE1}>"
      sh -c "$RESTORE_BOOT_CFG_STAGE1"
    fi
}

##########################################
# fail : try to resotore & reboot
##########################################

function fail {
    printf "${RED}[%s %s] ERROR:${NC} %s\n" "$(date +%T)" "${SCRIPT_NAME}" "${1}"
    clean
    exit -1
}

##########################################
# print help
##########################################

function printHelp {
  cat << EOI

  balena-migrate
    prepare host for migration to balena-os
    USAGE balena-stage1 [OPTIONS]
    please run as root
    OPTIONS:
      -c | --config <config file>  - Use given config file instead of /etc/balena-migrate.log
      --home <HOME_DIR>            - Use given path as home directory
      -h | --help                  - Print this help and exit
      -r | --reboot <DELAY>        - Reboot when done after a delay of DELAY seconds

EOI
  exit 0
}

##########################################
# Evaluate command line arguments
##########################################

function getCmdArgs {

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    arg="$1"
    case $arg in
      -h|--help)
          printHelp
          exit 0
          ;;
        -c|--config)
          if [ -z "$2" ]; then
            fail "\"$1\" argument needs a value."
          fi
          PARAM_CONFIG_FILE="$2"
          debug getCmdArgs "set PARAM_CONFIG_FILE=$PARAM_CONFIG_FILE"
          shift
          ;;
        --home)
          if [ -z "$2" ]; then
            fail "\"$1\" argument needs a value."
          fi
          PARAM_HOME_DIR="$2"
          debug getCmdArgs "set PARAM_HOME_DIR=$PARAM_HOME_DIR"
          shift
          ;;
        --balena-cfg)
          if [ -z "$2" ]; then
            fail "\"$1\" argument needs a value."
          fi
          PARAM_BALENA_CONFIG="$2"
          debug getCmdArgs "set PARAM_BALENA_CONFIG=$PARAM_BALENA_CONFIG"
          shift
          ;;
        --reboot)
          if [ -z "$2" ]; then
            fail "\"$1\" argument needs a value."
          fi
          PARAM_REBOOT="$2"
          debug getCmdArgs "set PARAM_REBOOT=$PARAM_REBOOT"
          shift
          ;;
        *)
          fail "invalid command $arg"
          ;;
    esac
    shift
  done
}


##########################################
# check if list contains string
##########################################
# careful how you call it, should be
# eg.: listContains "$SUPPORTED_OSTYPES" $OSTYPE
function listContains {
    for curr in $1
    do
        if [ "$2" == "$curr" ]; then
            return 0
        fi
    done
    return 1
}

##########################################
# check if programs are available
##########################################

function checkPgms {
  # shellcheck disable=SC2048
  for pgm in $*
  do
      debug checkPgms "checking $pgm"
      local pgmPath
      pgmPath="$(whereis -b "$pgm" | awk '{ print $2}')"
      if [ -z "$pgmPath" ] || [ ! -f "$pgmPath" ] ; then
        fail "cannot find required program: $pgm as $pgmPath"
     fi
  done
}


##########################################
# try to establish OS release
##########################################
checkOs() {
    local OS_ID OS_VERSION VERSION
    if [ -f /etc/os-release ]; then
        OS_ID=$(grep -e ^ID= /etc/os-release | sed "s/^ID=\(.*\)$/\1/")
        OS_VERSION=$(grep -e ^VERSION_ID= /etc/os-release | sed -n 's/^VERSION_ID="\?\([^"]*\)"\?$/\1/p')
        VERSION="$OS_ID-$OS_VERSION"
    else
        # other methods for other osses
        # hostnamectrl
        # lsb_release -a
        # add methods as you add osses that need different methods from above
        VERSION=
        fail "unable to retrieve OS version"
    fi
    echo "$VERSION"
}

##########################################
# copy a network manager wifi file
##########################################

function copy_nmgr_file {
  local FILE_NAME=$1
  if [ -f "${HOME_DIR}/${FILE_NAME}" ] ; then 
    if [ -z "$NETWORK_CONFIGS" ] ; then
      NETWORK_CONFIGS="$FILE_NAME"
    else
      NETWORK_CONFIGS="$NETWORK_CONFIGS $FILE_NAME"
    fi    
  fi
}

##########################################
# create a network manager wifi file
##########################################

function create_nmgr_file {
  local WIFI_NO=$1
  local WIFI_SSID=$2
  local WIFI_PSK=$3
  local FILE_NAME
  # shellcheck disable=SC2086
  FILE_NAME="resin-wifi-$(printf %02d $WIFI_NO)"

  cat << EOI > "${FILE_NAME}"
  [connection]
  id=$FILE_NAME
  type=wifi

  [wifi]
  hidden=true
  mode=infrastructure
  ssid=${WIFI_SSID}

  [wifi-security]
  auth-alg=open
  key-mgmt=wpa-psk
  psk=${WIFI_PSK}

  [ipv4]
  method=auto

  [ipv6]
  addr-gen-mode=stable-privacy
  method=auto
EOI
if [ -z "$NETWORK_CONFIGS" ] ; then
  NETWORK_CONFIGS="$FILE_NAME"
else
  NETWORK_CONFIGS="$NETWORK_CONFIGS $FILE_NAME"
fi
}

####################################################################################
# wether to migrate a ssid
####################################################################################

function migrate_this_wifi {
  local ssid="$*"
  debug "migrate_this_wifi" "ssid=<${ssid}> MIGRATE_ALL_WIFIS=${MIGRATE_ALL_WIFIS} MIGRATE_WIFI_CFG=${MIGRATE_WIFI_CFG} "
  if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] ; then
    debug "migrate_this_wifi" "migrate ALL, return 0"
    return 0
  else
      if [ -n "$MIGRATE_WIFI_CFG" ] && [ -f "${HOME_DIR}/${MIGRATE_WIFI_CFG}" ] ; then
          # debug "migrate_this_wifi: looking at ${HOME_DIR}/${MIGRATE_WIFI_CFG}"
          while read -r line
          do
            # debug "migrate_this_wifi: compare to: <$line>"
            if [ "$line" == "$ssid" ] ; then
              debug "migrate_this_wifi" "wifi found in ${HOME_DIR}/${MIGRATE_WIFI_CFG}, return 0"
              return 0
            fi
          done < "${HOME_DIR}/${MIGRATE_WIFI_CFG}"
      fi
  fi
  debug "migrate_this_wifi" " wifi not found, return 1"
  return 1
}

################################################################################
# Try to connect to host / port
################################################################################


function canConnect {
  local host port timeout tmpStr
  host=$1
  port=$2
  timeout=$3
  
  if [ -z "$timeout" ] ; then 
    timeout=20
  fi   

  tmpStr=$(nc -zvw${timeout} $host $port)
  echo "$tmpstr"

  if [[ $tmpStr =~ succeeded!$ ]] ; then     
    inform "successfully established connection to ${host}:${port} in ${elapsed} seconds"
    return 0
  else
    inform "failed to established connection to ${host}:${port}, timeout after ${elapsed} seconds"
    return 1    
  fi
}


####################################################################################
# extract wifi network config from wpa_supplicant.conf
####################################################################################

function wificfg_from_wpa {
  debug "wificfg_from_wpa" "NEXT_WIFI_IDX=${NEXT_WIFI_IDX} file=${WPA_SUPP_CONF}"

  while read -r line ;
  do
    if [[ $line =~ ^\ *network\ *=\ *\{ ]] ; then
      local network="TRUE"
      local ssid=
      local psk=
    else
      if [ "$network" == "TRUE" ] ; then
        if [[ $line =~ ^\ *} ]] ; then
          if [ -n "$ssid" ]  ; then
              debug "wificfg_from_wpa" "create_nmgr_file $NEXT_WIFI_IDX $ssid $psk"
              # shellcheck disable=SC2086
              create_nmgr_file $NEXT_WIFI_IDX "$ssid" "$psk"
              NEXT_WIFI_IDX=$((NEXT_WIFI_IDX + 1))
              ssid=
              psk=
              network=
          fi
          continue
        fi

        if [[ $line =~ ^\ *ssid\ *= ]] ; then
          local tmpSsid
          if [[ $line =~ \ *ssid\ *=\ *\"([^\"]+)\" ]] ; then
            tmpSsid="${BASH_REMATCH[1]}"
          else
            if [[ $line =~ \ *ssid\ *=\ *([^\ ]+)\ *$ ]] ; then
              tmpSsid="${BASH_REMATCH[1]}"
            fi
          fi

          if [ -n "$tmpSsid" ] ; then
            if migrate_this_wifi "$tmpSsid" ; then
              ssid=${tmpSsid}
            fi
          fi
          continue
        fi

        if [[ $line =~ ^\ *psk\ *= ]] ; then
          if [[ $line =~ \ *psk\ *=\ *\"([^\"]+)\" ]] ; then
            psk="${BASH_REMATCH[1]}"
          else
            if [[ $line =~ \ *psk\ *=\ *([^\ ]+)\ *$ ]] ; then
              psk="${BASH_REMATCH[1]}"
            fi
          fi
          continue
        fi
      fi
    fi
  done < "$WPA_SUPP_CONF"
}

##########################################
# migrate/copy NetworkManager files
##########################################

function wificfg_from_nmgr {

  debug "wificfg_from_nmgr" "NEXT_WIFI_IDX=${NEXT_WIFI_IDX}"

  for file in ${NMGR_DIR}/* ; do
    debug "wificfg_from_nmgr" "processing file: $file"

    local grepRes currSsid fileName

    grepRes=$(grep -E "^\s*type\s*=\s*wifi" "$file")
    if [ -z "$grepRes" ] ; then
      continue
    fi
    grepRes=$(grep -E "^\s*ssid\s*=.*" "$file")

    if [[ $grepRes =~ ssid\ *=\ *(.*)\ *$ ]] ; then
      currSsid="${BASH_REMATCH[1]}"

      if [ -n "$currSsid" ] &&  migrate_this_wifi "$currSsid" ; then
        inform "migrating wifi config for $currSsid"
        # TODO: only extract certain params or copy the whole thing ?
        fileName="resin-wifi-$(printf %02d $NEXT_WIFI_IDX)"
        cp "$file" "$fileName"
        NEXT_WIFI_IDX=$((NEXT_WIFI_IDX + 1))
      fi
    fi
  done
}

##########################################
# split partition name into parts
# /dev/nvme0n1p1 -> "/dev/ nvme0n1 1 p"
##########################################

function splitPartName {
    local partName pathName tmpName1 tmpName2 devName pad no
    partName=$1
    pathName=$(dirname "${partName}")
    tmpName1=$(lsblk -no kname "${partName}")
    tmpName2=$(readlink -f "/sys/class/block/${tmpName1}/..")
    devName=$(basename "${tmpName2}")
    tmp=${tmpName1:${#devName}}
    if [[ $tmp =~ ([^0-9]*)[0-9]+ ]] ; then
      pad="${BASH_REMATCH[1]}"
    else
      return 1
    fi

    if [[ $tmp =~ [^0-9]*([0-9]+) ]] ; then
      no=${BASH_REMATCH[1]}
    else
      return 1
    fi

    echo "${pathName} ${devName} ${no} ${pad}"
}

##########################################
# get root info
# get info about the mount point and path
# to /root
##########################################
function getBootInfo {
  if [ ! -d /boot ] ; then
    fail "boot directory could not be found"
  fi

  ROOT_FS=$(findmnt --noheadings --canonicalize --output SOURCE /)
  if [ -z "$ROOT_FS" ] ; then
    fail "root mount point could not be found"
  fi

  BOOT_FS=$(findmnt --noheadings --canonicalize --output SOURCE /boot)

  if [ -z "$BOOT_FS" ] ; then
    BOOT_FS=$ROOT_FS
  fi

  EFI_FS=$(findmnt --noheadings --canonicalize --output SOURCE /boot/efi)
}


##########################################
# check armvX arch  device
##########################################

function checkArmDevs {
  # local sysName=$(expr match "$(uname -a)" '^Linux \([ ]\+\)')
  local sysName tmp
  tmp="$(uname -a)"
  if [[ $tmp =~ ^Linux\ ([^\ ]+) ]] ; then
    sysName="${BASH_REMATCH[1]}"
  fi

  inform "platform is <${sysName}>"

  case "$sysName" in
    raspberrypi)
      inform "detected raspberry PI"
      RPI_HW_REV=$(awk '/^Revision/ {sub("^1000", "", $3); print $3}' /proc/cpuinfo)
      inform "RPI_HW_REV=$RPI_HW_REV"
      # shellcheck disable=SC2086
      if listContains "${RASPI_1_REVS}" ${RPI_HW_REV} ; then
        devType="armv7_rpi1"
        inform "device is a Raspberry PI 1"
        if [[ ! $IMAGE_NAME =~ raspberrypi1 ]] ; then
          fail "expected raspberrypi1 image, got $IMAGE_NAME"
        fi
      else
          # shellcheck disable=SC2086
          if listContains "${RASPI_2_REVS}" ${RPI_HW_REV} ; then
            devType="armv7_rpi2"
            inform "device is a Raspberry PI 2"
            if [[ ! $IMAGE_NAME =~ raspberry-pi2 ]] ; then
              fail "expected raspberrypi2 image, got $IMAGE_NAME"
            fi
          else
            # shellcheck disable=SC2086
            if listContains "${RASPI_3_REVS}" ${RPI_HW_REV} ; then
              devType="armv7_rpi1"
              inform "device is a Raspberry PI 3"
              if [[ ! $IMAGE_NAME =~ raspberrypi3 ]] ; then
                fail "expected raspberrypi3 image, got $IMAGE_NAME"
              fi
            else
              fail "no known PI revision found: $RPI_HW_REV"
            fi
          fi
      fi
    ;;
    beaglebone)
      # eg.: TI AM335x BeagleBone Green
      local tmp, variant
      tmp=$(cat "/proc/device-tree/model")
      if [[ $tmp =~ .*\ BeagleBone\ ([^\ ]+) ]] ; then
        variant="${BASH_REMATCH[1]}" # $(expr match "$tmp" '')
      fi

      inform "detected Beaglebone $variant device"

      case "$variant" in
        Green)
          if [[ ! $IMAGE_NAME =~ beaglebone-green ]] ; then
            fail "expected beaglebone-green image, got $IMAGE_NAME"
          fi
          devType="armv7_bb_green"
        ;;
        *)
          fail "not a supported Beaglebone variant: $variant"
        ;;
      esac
    ;;
    *)
      fail "unrecognized arm hardware platform: $sysName, 'uname -a' reports: $(uname -a)"
    ;;
  esac
}



####################################################
## setup raspbery pi to boot using initramfs
####################################################

function setupBootCfg_rpi {
  inform "setupBootCfg_rpi"
  ##########################
  ## Modify /boot/config.txt
  ##########################

  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} cp cat rm sleep"

  # make sure BUSYBOX is NOT used
  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1n/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"
  sed -i 's/^\(MODULES\s*=\s*\).*$/\1list/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"


  if [ "$NO_SETUP" != "TRUE" ] ; then
    # RESTORE_BOOT="TRUE"

    CONFIG_TXT_BACKUP="config.txt.$(date +%Y%m%d-%H-%M-%S)"

    cp "${S1_BOOT_PATH}/config.txt" "${S1_BOOT_PATH}/${CONFIG_TXT_BACKUP}"
    inform "created backup of ${S1_BOOT_PATH}/${CONFIG_TXT} in ${S1_BOOT_PATH}/${CONFIG_TXT_BACKUP}"
    RESTORE_BOOT_CFG_STAGE1="mv ${S1_BOOT_PATH}/${CONFIG_TXT_BACKUP} ${S1_BOOT_PATH}/config.txt"
    RESTORE_BOOT_CFG_STAGE2="cp ${S2_BOOT_PATH}/${CONFIG_TXT_BACKUP} ${S2_BOOT_PATH}/config.txt"

    TMP_FILE=$(mktemp)
    INITRAM_CMD="initramfs ${INITRAMFS_NAME} followkernel"

    while read -r line
    do
      if [[ $line =~ ^\ *\# ]] ; then
        echo "$line" >> "$TMP_FILE"
        continue
      fi

      if [[ $line =~ ^\ *initramfs ]] ; then
        if [ "$line" != "$INITRAM_CMD" ] ; then
          echo "# $line" >> "$TMP_FILE"
        fi
      else
        echo "$line" >> "$TMP_FILE"
      fi
    done < "${CONFIG_TXT}"
    echo "$INITRAM_CMD" >> "$TMP_FILE"
    cp "$TMP_FILE" "$CONFIG_TXT"
    rm "$TMP_FILE"

    ###########################
    ## Modify /boot/cmdline.txt
    ###########################

    if [ "$DEBUG" == "TRUE" ] ; then
      CMD_LINE=$(cat "${S1_BOOT_PATH}/cmdline.txt")
      if [[ ! $CMD_LINE =~ debug ]] ; then
        CMDLINE_TXT_BACKUP="cmdline.txt.$(date +%Y%m%d-%H-%M-%S)"
        inform "creating backup of ${CMDLINE_TXT} in ${CMDLINE_TXT_BACKUP}"
        cp "${S1_BOOT_PATH}/cmdline.txt"  "${S1_BOOT_PATH}/${CMDLINE_TXT_BACKUP}"
      	CMD_LINE="${CMD_LINE} debug"
      	echo "$CMD_LINE" > "${S1_BOOT_PATH}/cmdline.txt"

        RESTORE_BOOT_CFG_STAGE1="${RESTORE_BOOT_CFG_STAGE1} && mv ${S1_BOOT_PATH}/${CMDLINE_TXT_BACKUP} ${S1_BOOT_PATH}/cmdline.txt"
        RESTORE_BOOT_CFG_STAGE2="${RESTORE_BOOT_CFG_STAGE2} && cp ${S2_BOOT_PATH}/${CMDLINE_TXT_BACKUP} ${S2_BOOT_PATH}/cmdline.txt"
      fi
    fi

    if [ -n "${RESTORE_BOOT_CFG_STAGE2}" ] ; then
      RESTORE_BOOT_CFG_STAGE2="\"${RESTORE_BOOT_CFG_STAGE2}\""
    fi

    debug setupBootCfg_rpi "RESTORE_BOOT_CFG_STAGE1=${RESTORE_BOOT_CFG_STAGE1}"
    debug setupBootCfg_rpi "RESTORE_BOOT_CFG_STAGE2=${RESTORE_BOOT_CFG_STAGE2}"

  else
      inform "boot setup is disabled, NO_SETUP=$NO_SETUP"
  fi
}

####################################################
## setup beaglebone device to boot with initramfs
####################################################

function setupBootCfg_bb {
  debug setupBootCfg_bb "invoked"
  case $devType in
    armv7_bb_green)
      debug setupBootCfg_bb "for $devType"
    # modify bbb_uEnv.txt ?
    # TODO:
    #   target boot device mmcblk1 == eMMC ?
    #   determine current boot device mmcblk0 == SD , mmcblk1 == eMMC ?
    #   replace initramfs file or rename /bbb_uEnv.txt to /uEnv.txt and use alt initramfs
    #
      ##########################################################################
      # copy /bbb-uEnv.txt to /uEnv.txt if necessary, create restore cmd
      # TODO: make sure it is original/unmodified or create it fromm scratch
      ##########################################################################
      if [ ! -f "/uEnv.txt" ] ; then
          if [ -f "/bbb-uEnv.txt" ] ; then
            debug setupBootCfg_bb "found /bbb-uEnv.txt"
            cp /bbb-uEnv.txt /uEnv.txt || fail "failed to copy /bbb-uEnv.txt to /uEnv.txt"
            RESTORE_BOOT_CFG_STAGE1="rm /uEnv.txt"
            RESTORE_BOOT_CFG_STAGE2="\"rm ${S2_ROOTMOUNT}/uEnv.txt\""
          fi
      else
        debug setupBootCfg_bb "/uEnv.txt exists"
        local uEnvBckup
        uEnvBckup="/uEnv.txt.$(date +%Y%m%d-%H-%M-%S)"
        cp /uEnv.txt "$uEnvBckup"
        RESTORE_BOOT_CFG_STAGE1="cp $uEnvBckup /uEnv.txt"
        if [ "$ROOT_PART_NO" -eq "$BOOT_PART_NO" ] ; then
          RESTORE_BOOT_CFG_STAGE2="\"cp ${S2_ROOTMOUNT}${uEnvBckup} ${S2_ROOTMOUNT}/uEnv.txt\""
        else
          RESTORE_BOOT_CFG_STAGE2="\"cp ${S2_BOOTMOUNT}${uEnvBckup} ${S2_BOOTMOUNT}/uEnv.txt\""
        fi
      fi

      if [ ! -f "/uEnv.txt" ] ; then
        fail "setupBootCfg_bb, devType=${devType} could not find /uEnv.txt or /bbb-uEnv.txt"
      fi

      # fail "setupBootCfg_bb not implemented for devType=${devType}"
      ;;
    *)
      fail "setupBootCfg_bb not implemented for devType=${devType}"
    ;;
  esac



}

####################################################
## setup intel device to boot with initramfs
####################################################

function setupBootCfg_x86 {
  inform "setupBootCfg_x86"
  # TODO: grub boot device is set in $GRUB_BOOT_DEV - try to determine it from setup (eg. grub.conf)
  # TODO: assuming we are on debian like OS


  # check if this is an uefi booted system
  local efiBootMgr
  efiBootMgr=$(whereis -b efibootmgr | awk '{ print $2}')
  if [ -n "$efiBootMgr" ] &&  efibootmgr &>/dev/null ; then
    GRUB_BOOT_TYPE="UEFI"
    INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} efibootmgr" # TODO: might or might not be using it
  fi

  KERNEL_CMD_LINE=$(cat /proc/cmdline)

  if [ -z "$KERNEL_CMD_LINE" ] ; then
    fail "no kernel command line found"
  fi

  if [[ "$KERNEL_CMD_LINE" =~ ^BOOT_IMAGE=(.*)$ ]] ; then
    KERNEL_CMD_LINE="${BASH_REMATCH[1]}"
  else 
    fail "unexpected command line: $KERNEL_CMD_LINE"
  fi

  if [[ ! "$KERNEL_CMD_LINE" =~ boot= ]] ; then
    KERNEL_CMD_LINE="$KERNEL_CMD_LINE boot=local"
  fi

  if [ "$DEBUG" == "TRUE" ] ; then
    if [[ ! "$KERNEL_CMD_LINE" =~ debug ]] ; then
      KERNEL_CMD_LINE="$KERNEL_CMD_LINE debug"
    fi
  fi

  inform "KERNEL_CMD_LINE=$KERNEL_CMD_LINE"
  # inform "BOOT_DIR=$BOOT_DIR"

  if [ -z "$(whereis -b update-grub)" ] || [ -z "$(whereis -b grub-reboot)" ] ; then
      fail "failed to ensure required programs update-grub, grub-reboot"
  fi

  if [ ! -d /etc/grub.d ] ; then
      fail "grub configuration not found"
  fi

  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} busybox"
  # make sure BUSYBOX is used & **most** modules are present

  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1y/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"
  sed -i 's/^\(MODULES\s*=\s*\).*$/\1most/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"

  # TODO guess based on OS Version
  if [ "$GRUB_INSTALL" == "TRUE" ] ; then
    if [ -n "$GRUB_BOOT_IMG" ] && [ -n "$GRUB_CORE_IMG" ] ; then
      # attempt to flash boot images
      if [ ! -f "${HOME_DIR}/${GRUB_BOOT_IMG}" ] || [ ! -f "${HOME_DIR}/${GRUB_CORE_IMG}" ] ; then
        fail "could not locate boot images in ${HOME_DIR}/${GRUB_BOOT_IMG}, ${HOME_DIR}/${GRUB_CORE_IMG}"
      fi
      GRUB_INSTALL="FLASH"
    else
      # attempt to install grub from initramfs
      INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} grub-install"
      GRUB_INSTALL="INSTALL"
    fi

    if [ -n "$GRUB_CFG" ] ; then
      if [ ! -f "${HOME_DIR}/${GRUB_CFG}" ] ; then
        fail "grub config not found: ${GRUB_CFG}"
      fi
    else
      # TODO: use up to date grub config
      cat << EOI > ${HOME_DIR}/grub.cfg
serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1
default=boot
timeout=0

menuentry 'boot'{
linux /vmlinuz root=LABEL=resin-rootA rootwait quiet loglevel=0 splash udev.log-priority=3 vt.global_cursor_default=0 intel_idle.max_cstate=1
}
EOI
      GRUB_CFG="grub.cfg"
    fi
  fi

  if [ "$NO_SETUP" != "TRUE" ] ; then
    debug setupBootCfg_x86 "looking for boot device blkid"

    if [ -d /dev/disk/by-uuid ] ; then
      for fname in /dev/disk/by-uuid/* ; do
        debug setupBootCfg_x86 "looking at $fname"
        linkedFile=$(readlink "${fname}")
        debug setupBootCfg_x86 "go <${linkedFile}>"
        # shellcheck disable=SC2086
        if [ "$(basename $ROOT_FS)" == "$(basename $linkedFile)" ] ; then
          # debug setupBootCfg_x86 "found ${uuid} for ${ROOT_FS}"
          partId=$(basename "$fname")
          break
        fi
      done
    fi

    if [ -n "${partId}" ] ; then
      inform "found uuid: ${partId} for boot drive ${ROOT_FS}"
    fi

    if [ -n "$partId" ] ; then
      local setRootB="search --no-floppy --fs-uuid --set=root $partId"
    fi

    if [ "$GPT_TABLE" == "TRUE" ] ; then
      local partMod="part_gpt"
      local setRootA="set root='${GRUB_BOOT_DEV},gpt${ROOT_PART_NO}'"
    else
      local partMod="part_msdos"
      local setRootA="set root='${GRUB_BOOT_DEV},msdos${ROOT_PART_NO}'"
    fi

    inform "grub config, root: $setRootA"
    inform "grub config, root: $setRootB"

    cat <<EOI > /etc/grub.d/42_resin
#!/bin/sh
exec tail -n +3 \$0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.

menuentry "resin-migration" {
  insmod gzio
  insmod $partMod
  insmod ext2

  $setRootA
  $setRootB
  linux $KERNEL_CMD_LINE
  initrd  ${BOOT_DIR}/${INITRAMFS_NAME}
}
EOI
    chmod +x /etc/grub.d/42_resin

    inform "updating grub config using update-grub"
    update-grub || fail "failed to update grub config"
    inform "calling grub-reboot resin-migration"
    grub-reboot resin-migration
    RESTORE_BOOT_CFG_STAGE1="rm /etc/grub.d/42_resin && update-grub"
    RESTORE_BOOT_CFG_STAGE2=
else
    inform "boot setup is disabled, NO_SETUP=$NO_SETUP"
fi
}

####################################################################################
####################################################################################
# main : create initramfs & install it
####################################################################################
####################################################################################

# DEBUG_FUNCTS="migrate_this_wifi wificfg_from_wpa"
DEBUG_FUNCTS="main setupBootCfg_bb setupBootCfg_rpi getCmdArgs clean"

# script namme for logging
SCRIPT_NAME=$(basename "${0}")

CONFIG_FILE=balena-migrate.conf
HOME_DIR=./

color ON

debug main "checking command line args"

getCmdArgs "$@"

if [[ $EUID -ne 0 ]]; then
    fail "This script must be run as root"
fi

if [ -n "$PARAM_HOME_DIR" ] ; then
  HOME_DIR=$PARAM_HOME_DIR
fi

if [ -n "$PARAM_CONFIG_FILE" ] ; then
  CONFIG_FILE=$PARAM_CONFIG_FILE
fi

if [ -n "$PARAM_HOME_DIR" ] ; then
  # cmd line params take precedence over config file
  HOME_DIR=$PARAM_HOME_DIR
fi
inform "using home dir:     $HOME_DIR"

if [[ $HAS_WIFI_CFG =~ ^[0-9]+$ ]] ; then
  NEXT_WIFI_IDX=$((HAS_WIFI_CFG + 1))
else
  case $HAS_WIFI_CFG in
    TRUE)
      NEXT_WIFI_IDX=2
      ;;
    *)
      NEXT_WIFI_IDX=1
      ;;
  esac
fi

# let config file override some of the settings at the top of the file
if [[ "$CONFIG_FILE" =~ ^/.* ]] ; then
  # debug main " absolute path"
  if [ -f "$CONFIG_FILE" ] ; then
    inform "using config file: $CONFIG_FILE"
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
  else
    fail "config file not found ${CONFIG_FILE}"
  fi
else
  # debug main " relative path"
  if [ -f "${HOME_DIR}/${CONFIG_FILE}" ] ; then
    inform "using config file: ${HOME_DIR}/$CONFIG_FILE"
    # shellcheck source=/dev/null
    source "${HOME_DIR}/${CONFIG_FILE}"
  else
    if [ -f "${CONFIG_FILE}" ] ; then
      inform "using config file: $CONFIG_FILE"
      # shellcheck source=/dev/null
      source "${CONFIG_FILE}"
    else
      fail "config file could not be found ${CONFIG_FILE}"
    fi
  fi
fi

if [ -n "$PARAM_BALENA_CONFIG" ] ; then
  # cmd line params take precedence over config file
  BALENA_CONFIG="$PARAM_BALENA_CONFIG"
fi

if [ -n "$PARAM_REBOOT" ] ; then
  # cmd line params take precedence over config file
  DO_REBOOT="$PARAM_REBOOT"
fi


# name of backup file to create/transfer to balena-data
BACKUP_FILE=backup.tgz

# default grub config type
GRUB_BOOT_TYPE="legacy"

# raspi config.txt to modify
CONFIG_TXT="/boot/config.txt"
# raspi cmdline.txt to modify
CMDLINE_TXT="/boot/cmdline.txt"
# supported / tested OSSE's so far
SUPPORTED_OSSES="ubuntu-18.04 ubuntu-14.04 raspbian-9 debian-9"
# supported / tested platforms so far
SUPPORTED_ARCHS="x86_64 armv7l i686"

# mappings of RPi rev numbers to device types
RASPI_1_REVS="0002 0003 0004 0005 0006 0007 0008 0009 000d 000e 000f 0010 0011 0012 0013 0014 0015 900092 900093	920093 9000c1 900021 900032 900092 900093 920093 9000c1"
RASPI_2_REVS="a01040 a01041 a21041 a22042"
RASPI_3_REVS="a02082 a020a0 a22082 a32082 a020d3"

# minimum supported grub version
# TODO: implement it
# shellcheck disable=SC2034
GRUB_MIN_VER=2
# default boot directory
BOOT_DIR=/boot
# where the migrate conf is created - DO NOT MODIFY hardcoded in initramfs scripts
MIGRATE_CONF=/etc/balena-migrate-stage2.conf

# WPA_SUPP_CONF="/etc/wpa_supplicant/wpa_supplicant.conf"
WPA_SUPP_CONF="/etc/wpa_supplicant/wpa_supplicant.conf"
NMGR_DIR="/etc/NetworkManager/system-connections"

S2_ORIG_BOOT_MNT="/orig-boot"
S2_BOOT_PATH=
S2_MOUNT_BOOT=

# shellcheck disable=SC2016
S2_ROOTMOUNT='${rootmnt}'
# shellcheck disable=SC2016
S2_BOOTMOUNT='${ORIG_BOOT_MNT}'

RESTORE_BOOT_CFG_STAGE1=
RESTORE_BOOT_CFG_STAGE2=


inform "establishing required programs"

# TODO: Check / install tools needed for initramfs too
#       possible candidates: parted (on debian, beaglebone) blkid

INITRAM_REQUIRED_PGMS="cat cp dd df dirname echo expr grep gzip ls lsblk mkdir mv parted partprobe shutdown sleep stat sync touch udevadm"
REQUIRED_PGMS="awk file findmnt lsblk mkinitramfs parted readlink sed openssl"

if [ -n "$BALENA_API_HOST" ] || [ -n "$BALENA_VPN_HOST" ] ;  then 
  REQUIRED_PGMS="$REQUIRED_PGMS nc"
fi 

# shellcheck disable=SC2086
checkPgms $REQUIRED_PGMS

inform "found all required programs"

inform "checking disk space"
rootAvail=$(df / --output=avail | sed -n 2p)
if [ $rootAvail -lt $MIN_ROOT_AVAIL ] ; then 
  fail "not enough disk space available for migration, found ${rootAvail}KB, require  ${MIN_ROOT_AVAIL}KB"
fi
inform "found ${rootAvail}KB of space on / "

inform "LOG_DEBUG=${LOG_DEBUG}, DEBUG_FUNCTS=${DEBUG_FUNCTS}"

inform "checking required files"
if [[ ! $HOME_DIR =~ ^/.* ]] ; then
  CURR_DIR="$(pwd)"
  cd "$HOME_DIR" || fail "invalid/non existant HOME_DIR: $HOME_DIR"
  HOME_DIR=$(pwd)
  # shellcheck disable=SC2164
  cd "$CURR_DIR"
fi

if [ ! -d "$HOME_DIR" ] ; then
  fail "homedir does not exist: $HOME_DIR"
fi

inform "HOME_DIR=$HOME_DIR"

inform "checking connectivity"


if [ -n "$BALENA_API_HOST" ] && ! canConnect $BALENA_API_HOST $BALENA_API_PORT $BALENA_CONNECT_TIMEOUT ; then 
  fail "unable to connect to ${BALENA_API_HOST}:${BALENA_API_PORT} with timeout: ${BALENA_CONNECT_TIMEOUT}"
fi

if [ -n "$BALENA_VPN_HOST" ] && ! canConnect $BALENA_VPN_HOST $BALENA_VPN_PORT $BALENA_CONNECT_TIMEOUT ; then 
  fail "unable to connect to ${BALENA_VPN_HOST}:${BALENA_VPN_PORT} with timeout: ${BALENA_CONNECT_TIMEOUT}"
fi

##########################################
# prepare initramfs-tools dir in $HOME_DIR
##########################################

if [ -d "/etc/initramfs-tools" ] ; then
  inform "creating a copy of /etc/initramfs-tools in $HOME_DIR/initramfs-tools and populating it with migrate scripts"
  cp -r "/etc/initramfs-tools" "$HOME_DIR"
  cp "${HOME_DIR}/init-scripts/balena-init" "${HOME_DIR}/initramfs-tools/hooks/" || fail "failed to copy ${HOME_DIR}/init-scripts/balena-init to ${HOME_DIR}/initramfs-tools/hooks/"
  cp "${HOME_DIR}/init-scripts/balena-common" "${HOME_DIR}/initramfs-tools/scripts/" || fail "failed to copy ${HOME_DIR}/init-scripts/balena-common to ${HOME_DIR}/initramfs-tools/scripts"
  cp "${HOME_DIR}/init-scripts/balena-stage2-default" "${HOME_DIR}/initramfs-tools/scripts/local-bottom" || fail "failed to copy ${HOME_DIR}/init-scripts/balena-stage2-default to ${HOME_DIR}/initramfs-tools/scripts/local-bottom"
else
  fail "missing directory /etc/initramfs-tools"
fi

# name of initramfs to be created/used expected in $HOMEDIR
INITRAMFS_NAME="balena-migrate-initramfs-$(uname -r)"

##########################################
# check / repack image file
##########################################

if [ -z "$IMAGE_NAME" ] || [ ! -f "${HOME_DIR}/$IMAGE_NAME" ] ; then
  fail "missing image file: $IMAGE_NAME"
fi

TMP_IMG="${HOME_DIR}/${IMAGE_NAME}"
FTYPE=$(file -b "${TMP_IMG}")

if [[ ! $FTYPE =~ ^gzip\ compressed\ data.* ]] ; then
  if [[ $FTYPE =~ ^Zip\ archive\ data.* ]]  ; then
    inform "image file appears to be a zip archive, unzipping and repacking in gzip format.."
    TMP_DIR=$(mktemp -d -p "${HOME_DIR}")
    unzip "${TMP_IMG}" -d "$TMP_DIR" || fail "failed to unzip ${TMP_IMG}"
    TMP_IMG="${TMP_DIR}/$(ls "$TMP_DIR")"
    inform "got ${TMP_IMG}"
    FTYPE=$(file -b "$TMP_IMG")
  fi

  if [[ $FTYPE =~ ^DOS/MBR\ boot\ sector.* ]]  ; then
    inform "gzipping uncompressed image file $TMP_IMG.."
    gzip "$TMP_IMG" || fail "failed to gzip $TMP_IMG"
    # TMP_IMG=$(basename "${TMP_IMG}")#
    if [[ ${TMP_IMG} =~ .*/([^/]+/[^/]+)$ ]] ; then
      IMAGE_NAME="${BASH_REMATCH[1]}.gz"
    fi

    if [ -f "${HOME_DIR}/${IMAGE_NAME}" ] ; then
      inform "working with image $IMAGE_NAME"
    else
      fail "compressed image ${HOME_DIR}/${IMAGE_NAME} does not exist"
    fi
  else
    fail "cannot make sense of unzipped image file $TMP_IMG - expecting an image file, got $FTYPE"
  fi
else
  FTYPE=$(file -bz "${HOME_DIR}/${IMAGE_NAME}")
  if [[ ! $FTYPE =~ ^[^\ ]+\ boot\ sector.* ]]  ; then
    fail "cannot make sense of image file $TMP_IMG - expecting a gzipped image file, got $FTYPE"
  fi
fi

##########################################
# detect device / check for correct image ?
##########################################

ARCH=$(uname -m)

if ! listContains "$SUPPORTED_ARCHS" "$ARCH" ; then
  fail "not a supported architecture: $ARCH"
fi

case $ARCH in
  armv*)
    checkArmDevs
    ;;
  x86_64)
    inform "ARCH=$ARCH"
    devType="x86_64"
    if [[ ! $IMAGE_NAME =~ genericx86-64 ]] ; then
        warn "expected genericx86-64 image, got $IMAGE_NAME"
    fi
    ;;
  i686)
    devType="i686"
    inform "ARCH=$ARCH"
    if [[ ! $IMAGE_NAME =~ intel-core2-32 ]] && [[ ! $IMAGE_NAME =~ genericx86\..* ]] ; then
        warn "expected intel-core2-32 image, got $IMAGE_NAME"
    fi
    ;;
  *)
    fail "unknown / unsupported architecture: $ARCH"
    ;;
esac

# shellcheck disable=SC2086
checkPgms $INITRAM_REQUIRED_PGMS

KERNEL_VER=$(uname -r)
inform "KERNEL_VER=$KERNEL_VER"

OS_VERSION=$(checkOs)
inform "OS_VERSION=$OS_VERSION"

if ! listContains "${SUPPORTED_OSSES}" "${OS_VERSION}" ; then
    fail "not a supported OS ${OS_VERSION}"
fi

getBootInfo

inform "root partition: ${ROOT_FS} boot partition: ${BOOT_FS} EFI partition: ${EFI_FS}"

TMP=($(splitPartName "${BOOT_FS}"))

BOOT_PAD=${TMP[3]}
BOOT_DEV=${TMP[0]}/${TMP[1]}
BOOT_PART_NO=${TMP[2]}

TMP=($(splitPartName "${ROOT_FS}"))
ROOT_PART_NO=${TMP[2]}

if [ "$BOOT_DEV" != "${TMP[0]}/${TMP[1]}" ] ; then
  fail "unsupported boot configuration /boot is on a separate drive from / "
fi

if [ "$BOOT_PART_NO" -eq "$ROOT_PART_NO" ] ; then
  S2_BOOT_PATH="${S2_ROOTMOUNT}/boot"
  S2_MOUNT_BOOT=
  S1_BOOT_PATH="/boot"
else
  S2_MOUNT_BOOT="TRUE"
  S2_BOOT_PATH="${S2_BOOTMOUNT}"
  # TODO: determine path to /boot mount
  S1_BOOT_PATH="/boot"
fi

debug main "S2_BOOT_PATH=$S2_BOOT_PATH S2_MOUNT_BOOT=$S2_MOUNT_BOOT"

while read -r line ;
do
  # inform "parted line: $line"

  if [[ $line =~ ^Partition\ Table:\ gpt ]] ; then
    inform "gpt partition table found"
    GPT_TABLE="TRUE"
    continue
  fi

  # determine BOOT partitions FS type
  if [[ $line =~ ^${BOOT_PART_NO}.* ]] ; then
    parts=($line)
    if [ "$GPT_TABLE" == "TRUE" ] ; then
      BOOT_FS_TYPE=${parts[4]}
    else
      BOOT_FS_TYPE=${parts[5]}
    fi

    if [[ $BOOT_FS_TYPE =~ ^fat[0-9]+$ ]]  ; then
      BOOT_FS_TYPE="vfat"
    fi
    break
  fi
done < <(parted -s "${BOOT_DEV}" print)

inform "ROOT_DEV=${BOOT_DEV}, FS type: $BOOT_FS_TYPE"

###########################
## create boot configuration
###########################

case "$devType" in
    armv7_rpi*)
      inform "performing boot setup for RPI: $devType"
      setupBootCfg_rpi
    ;;
    armv7_bb*)
      inform "performing boot setup for Beaglebone: $devType"
      setupBootCfg_bb
    ;;
    x86_64|i686)
      inform "performing boot setup for other: $devType"
      setupBootCfg_x86
    ;;
esac

###########################
## migrate network config
###########################

NETWORK_CONFIGS=

if [ -n "$BALENA_CONFIG" ] && [ -f "${HOME_DIR}/${BALENA_CONFIG}" ] && [ "$BALENA_WIFI" == "TRUE" ] ; then
  # TODO: use jq instead ?
  jqPath="$(whereis -b jq | awk '{ print $2}')"
  if [ -z "$jqPath" ] ; then
    fail "program jq is required to extract wifi config from balena config, please install the program or set BALENA_WIFI to FALSE"
  fi

  inform "scanning ${HOME_DIR}/${BALENA_CONFIG} for wifi"
  wifiSsid=$(< "${HOME_DIR}/${BALENA_CONFIG}" jq .wifiSsid)
  debug main "wifiSsid=${wifiSsid}"

  if [ -n "$wifiSsid" ] && [[ $wifiSsid =~ ^\"(.+)\"$ ]] ; then
    wifiKey=$(< "${HOME_DIR}/${BALENA_CONFIG}" jq .wifiKey)
    debug main "wifiKey=${wifiKey}"
    if [ -n "$wifiKey" ] && [[ $wifiKey =~ ^\"(.+)\"$ ]] ; then
      inform "creating config for wifi $wifiSsid"
      create_nmgr_file $NEXT_WIFI_IDX "$wifiSsid" "$wifiKey"
      NEXT_WIFI_IDX=$((NEXT_WIFI_IDX + 1))
    fi
  fi
fi

if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] || [ -n "$MIGRATE_WIFI_CFG" ] ; then
  if [ -f "$WPA_SUPP_CONF" ] ; then
    wificfg_from_wpa
  else
    if [ -d "$NMGR_DIR" ] ; then
      wificfg_from_nmgr
    else
      warn "no supported wifi config found"
    fi
  fi
fi

if [ -n "$COPY_NMGR_FILES" ] ; then
  for file in $COPY_NMGR_FILES ; do 
    copy_nmgr_file "$file"
  done
fi

if [ -z "$NETWORK_CONFIGS" ] ; then
  if [ "$REQUIRE_NMGR_FILE" == "TRUE" ] ; then 
    fail "no network manager configurations found"
  else 
    warn "no network manager configurations found, device might be able to come online"
  fi  
fi 

###########################
## write /etc/migrate.conf
###########################


cat <<EOI > ${MIGRATE_CONF}
#!/bin/sh
# DO NOT EDIT ! This file is supposed to be created by stage1 script

REQUIRED_PGMS="$INITRAM_REQUIRED_PGMS"
LOG_DRIVE=${LOG_DRIVE}
LOG_FS_TYPE=${LOG_FS_TYPE}
LOG_MOUNT_DIR=/extlog
LOG_FILE=migrate.log

DEV_TYPE=$devType

BOOT_DEV=${BOOT_DEV}

ORIG_BOOT_MNT=${S2_ORIG_BOOT_MNT}
RESTORE_BOOT=${RESTORE_BOOT_CFG_STAGE2}
MOUNT_BOOT=${S2_MOUNT_BOOT}

ORIG_BOOT_PART=${BOOT_FS}
ORIG_ROOT_PART=${ROOT_FS}
ORIG_BOOT_FS_TYPE=${BOOT_FS_TYPE}

HOME_DIR=${HOME_DIR}
IMAGE_FILE=${IMAGE_NAME}
BACKUP_FILE=${BACKUP_FILE}

MIGRATE_TMP=/balena-migrate

BOOT_MNT_DIR=/resin-boot
BOOT_PART_NAME=${BOOT_DEV}${BOOT_PAD}1
BOOT_PART_TYPE=vfat

DATA_MNT_DIR=/resin-data
DATA_PART_NAME=${BOOT_DEV}${BOOT_PAD}6
DATA_PART_TYPE=ext4

NO_FLASH=${NO_FLASH}

TERM_EXIT="${TERM_EXIT}"

GRUB_INSTALL=${GRUB_INSTALL}
GRUB_CFG="$GRUB_CFG"
GRUB_BOOT_TYPE=${GRUB_BOOT_TYPE}
GRUB_PART_GPT=${GPT_TABLE}
GRUB_BOOT_IMG=${GRUB_BOOT_IMG}
GRUB_CORE_IMG=${GRUB_CORE_IMG}

BALENA_CONFIG="${BALENA_CONFIG}"
MEM_MIN_FREE=${MEM_MIN_FREE_S2}

NETWORK_CONFIGS="$NETWORK_CONFIGS"

EOI

###########################
## create initramfs
###########################

# set gzip compression
sed -i 's/^\(COMPRESS\s*=\s*\).*$/\1gzip/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"

OPTS="-d ${HOME_DIR}/initramfs-tools -o ${HOME_DIR}/${INITRAMFS_NAME}"
if [ "$MK_INITRAM_VERBOSE" == "TRUE" ] ; then
  OPTS="-v $OPTS"
fi

if [ "$MK_INITRAM_RETAIN" == "TRUE" ] ; then
  OPTS="-k $OPTS"
fi

inform "creating initramfs: mkinitramfs $OPTS"
# shellcheck disable=SC2086
mkinitramfs $OPTS || fail "failed to create initramfs in ${HOME_DIR}/${INITRAMFS_NAME}"

inform "copying ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"
cp "${HOME_DIR}/${INITRAMFS_NAME}" "${BOOT_DIR}/" || fail "failed to copy ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"

if [ -n "$BALENA_TMP_FILE" ] && [ -f "$BALENA_TMP_FILE" ] ; then
  rm "$BALENA_TMP_FILE"
fi

###########################
## create backup
###########################

if [ -n "$BACKUP_FILE" ] ; then
  if [ -n "$BACKUP_SCRIPT" ] ; then
    if [ -f "${HOME_DIR}/${BACKUP_SCRIPT}" ] ; then
      inform "invoking backup script using: ${HOME_DIR}/${BACKUP_SCRIPT} ${HOME_DIR}/${BACKUP_FILE}"
      "${HOME_DIR}/${BACKUP_SCRIPT}" "${HOME_DIR}/${BACKUP_FILE}" || fail "backup script ${HOME_DIR}/${BACKUP_SCRIPT} returned error code"
      inform "...done"
    else
      fail "cannot find backup script: ${HOME_DIR}/${BACKUP_SCRIPT}"
    fi
  else
    if [ -n "$BACKUP_DEFINITION" ] && [ -f "$BACKUP_DEFINITION" ] ; then
      if [ -f "${HOME_DIR}/$BACKUP_FILE" ] ; then
        rm "${HOME_DIR}/$BACKUP_FILE" || true
      fi
      "${HOME_DIR}/std-backup" "${HOME_DIR}/$BACKUP_FILE" "${HOME_DIR}/${BACKUP_DEFINITION}" || fail "failed to create backup using definition file ${HOME_DIR}/${BACKUP_DEFINITION}"
      inform "...done creating backup"
    fi
  fi

  if [ ! -f "${HOME_DIR}/${BACKUP_FILE}" ] ; then
    warn "no backup file created in: ${HOME_DIR}/${BACKUP_SCRIPT} ${HOME_DIR}/${BACKUP_FILE}"
  fi
fi

###########################
## check memory
###########################

totMem=$(< /proc/meminfo grep "MemTotal:")
if [[ $totMem =~ ^[^:]+:\ +([0-9]+)\ .* ]] ; then
  totMem=${BASH_REMATCH[1]}
  inform "total memory:  ${totMem} kB"
  leftMem=$totMem

  if [ -f "${HOME_DIR}/${IMAGE_NAME}" ] ; then
    tmp=$(stat -c %s "${HOME_DIR}/${IMAGE_NAME}")
    tmp=$((tmp / 1024))
    inform "image file size: ${tmp} kB "
    leftMem=$((leftMem - tmp))
  fi

  if [ -f "${HOME_DIR}/${BACKUP_FILE}" ] ; then
    tmp=$(stat -c %s "${HOME_DIR}/${BACKUP_FILE}")
    tmp=$((tmp / 1024))
    inform "backup file size: ${tmp} kB "
    leftMem=$((leftMem - tmp))
  fi
else
  warn "could not retrieve MemTotal value from <${totMem}>"
fi


fType=$(file "${HOME_DIR}/${INITRAMFS_NAME}")
if [[ "$fType" =~ ^[^:]+:.*cpio\ archive.* ]] ; then
  tmp=$(stat -c %s "${HOME_DIR}/${INITRAMFS_NAME}")
else
  if [[ $fType =~ ^[^:]+:[\ ]*gzip.* ]] ; then
    while read -r line ;
    do
      if echo "$line" | grep "${INITRAMFS_NAME}" > /dev/null ; then
        if [[ $line =~ [0-9]+\ +([0-9]+)\ .* ]]  ; then
          tmp="${BASH_REMATCH[1]}"
        fi
        break;
      fi
    done < <(gzip -l "${HOME_DIR}/${INITRAMFS_NAME}")
  else
    warn "unexpected initramfs format"
    tmp=$(stat -c %s "${HOME_DIR}/${INITRAMFS_NAME}")
  fi
fi

tmp=$((tmp / 1024))
inform "initramfs est. size: ${tmp} kB "
leftMem=$((leftMem - tmp))

inform "Est. memory left: ${leftMem} kB "
if [ ${leftMem} -lt ${MEM_MIN_FREE_S1} ] ; then
  fail "Est. memory left is less than set threshold (${MEM_MIN_FREE_S1} kB), reduce backup size or threshold in MEM_MIN_FREE_S1"
fi

###########################
## reboot
###########################


debug main "DO_REBOOT=$DO_REBOOT"

if [ -z "$DO_REBOOT" ] ; then
  DO_REBOOT=FALSE
fi

if [[ ! $DO_REBOOT =~ ^[0-9]+$ ]] ; then
    case $DO_REBOOT in
      TRUE)
        debug main "DO_REBOOT is TRUE: $DO_REBOOT"
        DO_REBOOT=1
        ;;
      *)
        debug main "DO_REBOOT is OTHER: $DO_REBOOT"
        DO_REBOOT=FALSE
        ;;
    esac
fi

debug main "using DO_REBOOT: $DO_REBOOT"

if [[ $DO_REBOOT =~ ^[0-9]+$ ]] ; then
  delay=${BASH_REMATCH[0]}
  inform "migration successful, rebooting system in ${delay} minutes"
  shutdown -r +${delay}
else
  inform "migration successful, please reboot system"
fi
