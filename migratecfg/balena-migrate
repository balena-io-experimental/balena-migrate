#!/bin/bash
####################################################################
# balena-stage1
# setup migration for brown-field device to balena
####################################################################

####################################################################
# TODO: parted not installed on default beaglebone debian install,
#       install or replace
# TODO: add -r --reboot cmdline parameters
# TODO: attempt to detect flasher images
#
####################################################################


################################################################################
################################################################################
# All of the following variables can be overridden in /etc/balena-migrate.conf
################################################################################
################################################################################

################################################################################
# attempt to mount and log initramfs logs to external drive if set
LOG_DRIVE=/dev/sdb1
LOG_FS_TYPE=ext4

################################################################################
# where everything is
# TODO: establish & use an absolute path to a set home directory that is not
#       necessarily PWD
HOME_DIR=./

################################################################################
# reboot automatically after script has finished by setting to "TRUE"
DO_REBOOT= # "TRUE"

################################################################################
# name of the balenaOS image to flash (expected in $HOMEDIR)
# must be set in /etc/balena-migrate.conf
# IMAGE_NAME="resin-image-genericx86-64.resinos-img.gz"
# IMAGE_NAME="resin-resintest-raspberrypi3-2.15.1+rev2-dev-v7.16.6.img.gz"

################################################################################
# Use wifi config provided in image if set to TRUE
HAS_WIFI_CFG="FALSE" # set to "TRUE" if a wifi config is provided in image

################################################################################
# create NM configs from all configs found in this system
MIGRATE_ALL_WIFIS="FALSE" # migrate all wifis if set to "TRUE"

################################################################################
# only create NM wifi configs for ssids listed in this file
# file with a list of wifi networks to migrate, one per line
MIGRATE_WIFI_CFG="migrate-wifis"

################################################################################
# inject the config.json provided under the given filename into resin-boot
# set to the path of a config.json file to copy to the image
BALENA_CONFIG=

################################################################################
# if set to TRUE attempt to extract a wifi config from config.json given in
# BALENA_CONFIG
BALENA_WIFI=

################################################################################
# switch on initramfs / kernel debug mode by seting to "TRUE"
DEBUG= # "TRUE"

################################################################################
# name of backup file to create/transfer to balena-data
BACKUP_FILE=backup.tgz

################################################################################
# TODO: customer defined backup script to call
BACKUP_SCRIPT=

################################################################################
# arguments to tar -czf $BACKUP_FILE if no backup script is given
BACKUP_DIRECTORIES="/etc"

################################################################################
# Grub boot device in grub notation - usually not nee
GRUB_BOOT_DEV="hd0"

################################################################################
# minimum free memory in stage 2
# stage 2 script reads free memory
#   subtracts size of image file & backup files
#   fails if remaining space is less than the value given in MEM_MIN_FREE
MEM_MIN_FREE_S2=65536   # 64 MB as kB

################################################################################
# minimum free memory in stage 1
# stage 1 script reads total memory
#   subtracts size of image file & backup files & initramfs
#   fails if remaining space is less than the value given in MEM_MIN_FREE
MEM_MIN_FREE_S1=65536   # 64 MB as kB

################################################################################
# DEBUG end initramfs scripts before unmounting root / flashing the image
NO_FLASH= #"TRUE"

################################################################################
# DEBUG: do not modify config.txt, cmdline.txt, grub config if set to "TRUE"
NO_SETUP= #{ }"TRUE"

################################################################################
# create initramfs in contrast to using an initramfs supplied
MK_INITRAMFS="TRUE"

################################################################################
# DEBUG verbose build process
MK_INITRAM_VERBOSE= # "TRUE"

################################################################################
# DEBUG keep initramfs layout
MK_INITRAM_RETAIN= # "TRUE"

################################################################################
# DEBUG enable DEBUG messages if set to TRUE
LOG_DEBUG="TRUE"

##########################################
# log functions
##########################################

function color {
  if [ -n "$1" ] ; then
    YELLOW='\033[1;33m'
    BROWN='\033[0;33m'
    GREEN='\033[0;32m'
    RED='\033[0;31m'
    NC='\033[0m' # No Color
  else
    YELLOW=
    BROWN=
    GREEN=
    RED=
    NC=
  fi
}

function inform {
    printf "${GREEN}[$(date +%T) ${SCRIPT_NAME}] INFO: ${NC} ${1}\n"
}

function warn {
    printf "${YELLOW}[$(date +%T) ${SCRIPT_NAME}] WARN: ${NC} ${1}\n"
}

function debug {
    if [ "$LOG_DEBUG" == "TRUE" ] && listContains "$DEBUG_FUNCTS" $1 ; then
      printf "${BROWN}[$(date +%T) ${SCRIPT_NAME}] DEBUG:${NC} ${1}: ${2}\n"
    fi
}

function simulate {
    printf "${GREEN}[$(date +%T) ${SCRIPT_NAME}] INFO: ${NC} would execute \"$*\"\n"
}

function clean {
    if [ -n "$TMP_DIR" ] && [ -d "$TMP_DIR" ] ; then
      rm -rf "$TMP_DIR"
    fi

    if [ -n "$RESTORE_BOOT_CFG_STAGE1" ] ; then
      $RESTORE_BOOT_CFG_STAGE1
    fi
}

##########################################
# fail : try to resotore & reboot
##########################################

function fail {
    printf "${RED}[$(date +%T) ${SCRIPT_NAME}] ERROR:${NC} $1\n"
    clean
    exit -1
}

##########################################
# print help
##########################################

function printHelp {
  echo "balena-stage1"
  echo "  prepare host for migration to balena-os"
  echo "  USAGE balena-stage1 [OPTIONS]"
  echo "  please run as root"
  echo "  OPTIONS: "
  echo "    -c <config file> | --config=<config file> : use given config file instead of /etc/balena-migrate.log "
  echo "    --home=<HOME_DIR>                         : use given path as home directory"
  echo "    -h | --help                               : print this help and exit"
  echo "    -r <DELAY> | --reboot=<DELAY>             : reboot when done after a delay of DELAY seconds"
  echo "    -u <UUID> | --uuid=<UUID>                 : use given UUID as baleanOS host id"
  exit 0
}

##########################################
# Evaluate command line arguments
##########################################

function getCmdArgs {
  cmd=
  for var in "$@"
  do
    debug getCmdArgs "looking at $var"
    if [ -n "$cmd" ]  ; then
      case $cmd in
        config)
          $PARAM_CONFIG_FILE=$var
          cmd=
          ;;
        uuid)
          $PARAM_UUID=$var
          cmd=
          ;;
        home)
          $PARAM_HOME_DIR=$var
          cmd=
          ;;
        *)
          fail "unrecognized parameter ${var}"
          ;;
      esac
    else
      if [[ "$var" =~ ^--.* ]] ; then
        cmd=$(expr match "$var" '^--\([^=]\+\).*')
        param=$(expr match "$var" '^--[^=]\+=\(.*\)$') || true
        case "$cmd" in
          config)
            if [ -n "$param" ] ; then
              PARAM_CONFIG_FILE="$param"
            else
              fail "missing parameter for $var"
            fi
            ;;
          uuid)
            if [ -n "$param" ] ; then
              PARAM_UUID=$param
            else
              fail "missing parameter for $var"
            fi
            ;;
          home)
            if [ -n "$param" ] ; then
              PARAM_HOME_DIR="$param"
            else
              fail "missing parameter for $var"
            fi
            ;;
          balena-cfg)
            if [ -n "$param" ] ; then
              PARAM_BALENA_CONFIG="$param"
            else
              fail "missing parameter for $var"
            fi
            ;;
          help)
            printHelp
            ;;
          *)
            fail "invalid command $var"
            ;;
        esac
        cmd=
      else
        if [[ "$var" =~ ^-.* ]] ; then
          debug getCmdArgs "$var starts with -"
          case "$var" in
            -c)
              cmd="config"
              ;;
            -u)
              cmd="uuid"
              ;;
            -h)
              printHelp
              ;;
            *)
              fail "unrecognized command: $var"
              cmd=
              ;;
          esac
        else
          fail "unrecognized command: $var"
        fi
      fi
    fi
    debug getCmdArgs "command=$cmd"
  done
}


##########################################
# check if list contains string
##########################################
# careful how you call it, should be
# eg.: listContains "$SUPPORTED_OSTYPES" $OSTYPE
function listContains {
    for curr in $1
    do
        if [ "$2" == "$curr" ]; then
            return 0
        fi
    done
    return 1
}

##########################################
# check if programs are available
##########################################

function checkPgms {
  for pgm in $*
  do
      local pgmPath="$(whereis -b $pgm | awk '{ print $2}')"
      if [ -z "$pgmPath" ] || [ ! -f "$pgmPath" ] ; then
        fail "cannot find required program: $pgm as $pgmPath"
     fi
  done
}


##########################################
# try to establish OS release
##########################################
checkOs() {
    if [ -f /etc/os-release ]; then
        local OS_ID=$(grep -e ^ID= /etc/os-release | sed "s/^ID=\(.*\)$/\1/")
        local OS_VERSION=$(grep -e ^VERSION_ID= /etc/os-release | sed -n 's/^VERSION_ID="\?\([^"]*\)"\?$/\1/p')
        VERSION="$OS_ID-$OS_VERSION"
    else
        # other methods for other osses
        # hostnamectrl
        # lsb_release -a
        # add methods as you add osses that need different methods from above
        VERSION=
        fail "unable to retrieve OS version"
    fi
    echo "$VERSION"
}

##########################################
# create a network manager wifi file
##########################################

function create_nmgr_file {
  local WIFI_NO=$1
  local WIFI_SSID=$2
  local WIFI_PSK=$3
  local FILE_NAME="resin-wifi-`printf %02d $WIFI_NO`"

  cat << EOI > ${FILE_NAME}
  [connection]
  id=$FILE_NAME
  type=wifi

  [wifi]
  hidden=true
  mode=infrastructure
  ssid=${WIFI_SSID}

  [wifi-security]
  auth-alg=open
  key-mgmt=wpa-psk
  psk=${WIFI_PSK}

  [ipv4]
  method=auto

  [ipv6]
  addr-gen-mode=stable-privacy
  method=auto
EOI
if [ -z "$NETWORK_CONFIGS" ] ; then
  NETWORK_CONFIGS="$FILE_NAME"
else
  NETWORK_CONFIGS="$NETWORK_CONFIGS $FILE_NAME"
fi
}

####################################################################################
# wether to migrate a ssid
####################################################################################

function migrate_this_wifi {
  local ssid="$*"
  debug "migrate_this_wifi" "ssid=<${ssid}> MIGRATE_ALL_WIFIS=${MIGRATE_ALL_WIFIS} MIGRATE_WIFI_CFG=${MIGRATE_WIFI_CFG} "
  if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] ; then
    debug "migrate_this_wifi" "migrate ALL, return 0"
    return 0
  else
      if [ -n "$MIGRATE_WIFI_CFG" ] && [ -f "${HOME_DIR}/${MIGRATE_WIFI_CFG}" ] ; then
          # debug "migrate_this_wifi: looking at ${HOME_DIR}/${MIGRATE_WIFI_CFG}"
          while read line
          do
            # debug "migrate_this_wifi: compare to: <$line>"
            if [ "$line" == "$ssid" ] ; then
              debug "migrate_this_wifi" "wifi found in ${HOME_DIR}/${MIGRATE_WIFI_CFG}, return 0"
              return 0
            fi
          done < "${HOME_DIR}/${MIGRATE_WIFI_CFG}"
      fi
  fi
  debug "migrate_this_wifi" " wifi not found, return 1"
  return 1
}

####################################################################################
# extract wifi network config from wpa_supplicant.conf
####################################################################################

function wificfg_from_wpa {
  local cfgNo=1

  if [ "$HAS_WIFI_CFG" == "TRUE" ] ; then
    cfgNo=2
  fi

  debug "wificfg_from_wpa" "cfgNo=${cfgNo} file=${WPA_SUPP_CONF}"

  while read line ;
  do
    if [[ $line =~ ^\s*network\s*=\s*\{ ]] ; then
      local network="TRUE"
      local ssid=
      local psk=
    else
      if [ "$network" == "TRUE" ] ; then
        if [[ $line =~ ^\s*} ]] ; then
          if [ -n "$ssid" ]  ; then
              debug "wificfg_from_wpa" "create_nmgr_file $cfgNo $ssid $psk"
              create_nmgr_file $cfgNo "$ssid" "$psk"
              cfgNo=$((cfgNo + 1))
              ssid=
              psk=
              network=
          fi
          continue
        fi

        if [[ $line =~ ^\s*ssid\s*= ]] ; then

          local tmpSsid=$(expr match "$line" '\s*ssid\s*=\s*"\([^"]\+\)"')

          if [ -z "$tmpSsid" ] ; then
            tmpSsid=$(expr match "$line" '\s*ssid\s*=\s*\(\S\+\)')
          fi

          if migrate_this_wifi $tmpSsid ; then
            ssid=${tmpSsid}
          fi
          continue
        fi

        if [[ $line =~ ^\s*psk\s*= ]] ; then
          # debug "wificfg_from_wpa" "psk in line : <${line}>"
          psk=$(expr match "$line" '\s*psk\s*=\s*"\([^"]\+\)"')
          if [ -z "$psk" ] ; then
            psk=$(expr match "$line" '\s*psk\s*=\s*\(\S\+\)')
          fi
          continue
        fi
      fi
    fi
  done < $WPA_SUPP_CONF
}

##########################################
# migrate/copy NetworkManager files
##########################################

function wificfg_from_nmgr {
  local cfgNo=1
  if [ "$HAS_WIFI_CFG" == "TRUE" ] ; then
    cfgNo=2
  fi

  debug "wificfg_from_nmgr" "cfgNo=${cfgNo}"

  for file in ${NMGR_DIR}/* ; do
    debug "wificfg_from_nmgr" "processing file: $file"

    local grepRes=$(grep -E "^\s*type\s*=\s*wifi" "$file")
    if [ -z "$grepRes" ] ; then
      continue
    fi
    grepRes=$(grep -E "^\s*ssid\s*=.*" "$file")
    local currSsid=$(expr match "$grepRes" 'ssid\s*=\s*\(.*\)')

    if  migrate_this_wifi $currSsid ; then
      inform "migrating wifi config for $currSsid"
      # TODO: only extract certain params or copy the whole thing ?
      local fileName="resin-wifi-`printf %02d $cfgNo`"
      cp "$file" "$fileName"
      cfgNo=$((cfgNo + 1))
    fi
  done
}

##########################################
# split partition name into parts
# /dev/nvme0n1p1 -> "/dev/ nvme0n1 1 p"
##########################################

function splitPartName {
    local partName=$1
    local pathName=$(dirname "${partName}")
    local tmpName1=$(lsblk -no kname ${partName})
    local tmpName2=$(readlink -f "/sys/class/block/${tmpName1}/..")
    local devName=$(basename "${tmpName2}")
    local tmp=${tmpName1:${#devName}}
    local pad=$(expr match "${tmp}" '\([^0-9]*\)[0-9]\+')
    local no=$(expr match "${tmp}" '[^0-9]*\([0-9]\+\)')
    echo "${pathName} ${devName} ${no} ${pad}"
}

##########################################
# get root info
# get info about the mount point and path
# to /root
##########################################
function getBootInfo {
  if [ ! -d /boot ] ; then
    fail "boot directory could not be found"
  fi

  ROOT_FS=$(findmnt --noheadings --canonicalize --output SOURCE /)
  if [ -z "$ROOT_FS" ] ; then
    fail "root mount point could not be found"
  fi

  BOOT_FS=$(findmnt --noheadings --canonicalize --output SOURCE /boot)

  if [ -z "$BOOT_FS" ] ; then
    BOOT_FS=$ROOT_FS
  fi

  EFI_FS=$(findmnt --noheadings --canonicalize --output SOURCE /boot/efi)
}


##########################################
# check armvX arch  device
##########################################

function checkArmDevs {
  # local sysName=$(expr match "$(uname -a)" '^Linux \([ ]\+\)')
  local sysName=$(expr match "$(uname -a)" '^Linux \([^ ]\+\)')
  inform "platform is <${sysName}>"

  case "$sysName" in
    raspberrypi)
      inform "detected raspberry PI"
      RPI_HW_REV=$(awk '/^Revision/ {sub("^1000", "", $3); print $3}' /proc/cpuinfo)
      inform "RPI_HW_REV=$RPI_HW_REV"
      if listContains "${RASPI_1_REVS}" ${RPI_HW_REV} ; then
        devType="armv7_rpi1"
        inform "device is a Raspberry PI 1"
        if [[ ! $IMAGE_NAME =~ raspberrypi1 ]] ; then
          fail "expected raspberrypi1 image, got $IMAGE_NAME"
        fi
      else
          if listContains "${RASPI_2_REVS}" ${RPI_HW_REV} ; then
            devType="armv7_rpi2"
            inform "device is a Raspberry PI 2"
            if [[ ! $IMAGE_NAME =~ raspberry-pi2 ]] ; then
              fail "expected raspberrypi2 image, got $IMAGE_NAME"
            fi
          else
            if listContains "${RASPI_3_REVS}" ${RPI_HW_REV} ; then
              devType="armv7_rpi1"
              inform "device is a Raspberry PI 3"
              if [[ ! $IMAGE_NAME =~ raspberrypi3 ]] ; then
                fail "expected raspberrypi3 image, got $IMAGE_NAME"
              fi
            else
              fail "no known PI revision found: $RPI_HW_REV"
            fi
          fi
      fi
    ;;
    beaglebone)
      # eg.: TI AM335x BeagleBone Green
      local tmp=$(cat "/proc/device-tree/model")
      local variant=$(expr match "$tmp" '.* BeagleBone \([^ ]\+\)')

      inform "detected Beaglebone $variant device"

      case "$variant" in
        Green)
          if [[ ! $IMAGE_NAME =~ beaglebone-green ]] ; then
            fail "expected beaglebone-green image, got $IMAGE_NAME"
          fi
          devType="armv7_bb_green"
        ;;
        *)
          fail "not a supported Beaglebone variant: $variant"
        ;;
      esac
    ;;
    *)
      fail "unrecognized arm hardware platform: $sysName, 'uname -a' reports: $(uname -a)"
    ;;
  esac
}



####################################################
## setup raspbery pi to boot using initramfs
####################################################

function setupBootCfg_rpi {
  inform "setupBootCfg_rpi"
  ##########################
  ## Modify /boot/config.txt
  ##########################

  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} cp cat rm sleep"

  # make sure BUSYBOX is NOT used
  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1n/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"
  sed -i 's/^\(MODULES\s*=\s*\).*$/\1list/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"


  if [ "$NO_SETUP" != "TRUE" ] ; then
    RESTORE_BOOT="TRUE"

    CONFIG_TXT_BACKUP="config.txt.$(date +%Y%m%d-%H-%M-%S)"

    cp "${S1_BOOT_PATH}/config.txt" "${S1_BOOT_PATH}/${CONFIG_TXT_BACKUP}"
    inform "created backup of ${S1_BOOT_PATH}/${CONFIG_TXT} in ${S1_BOOT_PATH}/${CONFIG_TXT_BACKUP}"
    RESTORE_BOOT_CFG_STAGE1="mv ${S1_BOOT_PATH}/${CONFIG_TXT_BACKUP} ${S1_BOOT_PATH}/config.txt"
    RESTORE_BOOT_CFG_STAGE2="cp ${S2_BOOT_PATH}/${CONFIG_TXT_BACKUP} ${S2_BOOT_PATH}/config.txt"

    TMP_FILE=$(mktemp)
    INITRAM_CMD="initramfs ${INITRAMFS_NAME} followkernel"

    while read -r line
    do
      if [[ $line =~ ^\s*\# ]] ; then
        echo $line >> $TMP_FILE
        continue
      fi

      if [[ $line =~ ^\s*initramfs ]] ; then
        if [ "$line" != "$INITRAM_CMD" ] ; then
          echo "# $line" >> $TMP_FILE
        fi
      else
        echo $line >> $TMP_FILE
      fi
    done < "${CONFIG_TXT}"
    echo $INITRAM_CMD >> $TMP_FILE
    cp $TMP_FILE $CONFIG_TXT
    rm $TMP_FILE

    ###########################
    ## Modify /boot/cmdline.txt
    ###########################

    if [ "$DEBUG" == "TRUE" ] ; then
      CMD_LINE=$(cat "${S1_BOOT_PATH}/cmdline.txt")
      if [[ ! $CMD_LINE =~ debug ]] ; then
        CMDLINE_TXT_BACKUP="cmdline.txt.$(date +%Y%m%d-%H-%M-%S)"
        inform "creating backup of ${CMDLINE_TXT} in ${CMDLINE_TXT_BACKUP}"
        cp ${S1_BOOT_PATH}/cmdline.txt  ${S1_BOOT_PATH}/${CMDLINE_TXT_BACKUP}
      	CMD_LINE="${CMD_LINE} debug"
      	echo $CMD_LINE > ${S1_BOOT_PATH}/cmdline.txt

        RESTORE_BOOT_CFG_STAGE1="${RESTORE_BOOT_CFG_STAGE1} && mv ${S1_BOOT_PATH}/${CMDLINE_TXT_BACKUP} ${S1_BOOT_PATH}/cmdline.txt"
        RESTORE_BOOT_CFG_STAGE2="${RESTORE_BOOT_CFG_STAGE2} && cp ${S2_BOOT_PATH}/${CMDLINE_TXT_BACKUP} ${S2_BOOT_PATH}/cmdline.txt"
      fi
    fi

    if [ -n "${RESTORE_BOOT_CFG_STAGE2}" ] ; then
      RESTORE_BOOT_CFG_STAGE2="\"${RESTORE_BOOT_CFG_STAGE2}\""
    fi

    debug setupBootCfg_rpi "RESTORE_BOOT_CFG_STAGE1=${RESTORE_BOOT_CFG_STAGE1}"
    debug setupBootCfg_rpi "RESTORE_BOOT_CFG_STAGE2=${RESTORE_BOOT_CFG_STAGE2}"

  else
      inform "boot setup is disabled, NO_SETUP=$NO_SETUP"
  fi
}

####################################################
## setup beaglebone device to boot with initramfs
####################################################

function setupBootCfg_bb {
  debug setupBootCfg_bb "invoked"
  case $devType in
    armv7_bb_green)
      debug setupBootCfg_bb "for $devType"
    # modify bbb_uEnv.txt ?
    # TODO:
    #   target boot device mmcblk1 == eMMC ?
    #   determine current boot device mmcblk0 == SD , mmcblk1 == eMMC ?
    #   replace initramfs file or rename /bbb_uEnv.txt to /uEnv.txt and use alt initramfs
    #
      ##########################################################################
      # copy /bbb-uEnv.txt to /uEnv.txt if necessary, create restore cmd
      # TODO: make sure it is original/unmodified or create it fromm scratch
      ##########################################################################
      if [ ! -f "/uEnv.txt" ] ; then
          if [ -f "/bbb-uEnv.txt" ] ; then
            debug setupBootCfg_bb "found /bbb-uEnv.txt"
            cp /bbb-uEnv.txt /uEnv.txt || fail "failed to copy /bbb-uEnv.txt to /uEnv.txt"
            RESTORE_BOOT_CFG_STAGE1="rm /uEnv.txt"
            RESTORE_BOOT_CFG_STAGE2="\"rm ${S2_ROOTMOUNT}/uEnv.txt\""
          fi
      else
        debug setupBootCfg_bb "/uEnv.txt exists"
        local uEnvBckup="/uEnv.txt.$(date +%Y%m%d-%H-%M-%S)"
        cp /uEnv.txt "$uEnvBckup"
        RESTORE_BOOT_CFG_STAGE1="cp $uEnvBckup /uEnv.txt"
        if [ $ROOT_PART_NO -eq $BOOT_PART_NO ] ; then
          RESTORE_BOOT_CFG_STAGE2="\"cp ${S2_ROOTMOUNT}${uEnvBckup} ${S2_ROOTMOUNT}/uEnv.txt\""
        else
          RESTORE_BOOT_CFG_STAGE2="\"cp ${S2_BOOTMOUNT}${uEnvBckup} ${S2_BOOTMOUNT}/uEnv.txt\""
        fi
      fi

      if [ ! -f "/uEnv.txt" ] ; then
        fail "setupBootCfg_bb, devType=${devType} could not find /uEnv.txt or /bbb-uEnv.txt"
      fi

      # fail "setupBootCfg_bb not implemented for devType=${devType}"
      ;;
    *)
      fail "setupBootCfg_bb not implemented for devType=${devType}"
    ;;
  esac



}

####################################################
## setup intel device to boot with initramfs
####################################################

function setupBootCfg_other {
  inform "setupBootCfg_other"
  # TODO: grub boot device is set in $GRUB_BOOT_DEV - try to determine it from setup (eg. grub.conf)
  # TODO: assuming we are on debian like OS

  INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} grub-install busybox"

  # make sure BUSYBOX is used & **most** modules are present
  inform "checking initramfs-tools config"
  sed -i 's/^\(BUSYBOX\s*=\s*\).*$/\1y/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"
  sed -i 's/^\(MODULES\s*=\s*\).*$/\1most/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"

  # check if this is an uefi booted system
  local efiBootMgr=$(whereis -b efibootmgr | awk '{ print $2}')
  if [ -n "$efiBootMgr" ] &&  efibootmgr &>/dev/null ; then
    GRUB_BOOT_TYPE="UEFI"
    INITRAM_REQUIRED_PGMS="${INITRAM_REQUIRED_PGMS} efibootmgr" # TODO: might or might not be using it
  fi

  local KERNEL_CMD_LINE_RAW=$(cat /proc/cmdline)
  if [ -z "$KERNEL_CMD_LINE_RAW" ] ; then
    fail "no kernel command line found"
  fi

  case "$KERNEL_CMD_LINE_RAW" in
     BOOT_IMAGE=*)
        # Ubuntu version
        local KERNEL_CMD_LINE=$(expr match "$KERNEL_CMD_LINE_RAW" '^BOOT_IMAGE=\(.*\)')
        # local KERNEL_CMD_LINE="vmlinuz-4.4.0-31-generic root=UUID=1bddfe9b-69cd-499d-bd21-2639700a899e ro"
        local TMP=($KERNEL_CMD_LINE)

        #KBOOT_DIR=$(dirname ${TMP[0]})
        #if [ "$KBOOT_DIR" != "/boot" ] ; then
        #   # boot config does not appear to be on root partition
        #  if [ "$KBOOT_DIR" == "." ] ; then
        #    $KBOOT_DIR=
        #  else
        #     $KBOOT_DIR="$KBOOT_DIR/"
        #  fi
        #else
        #  KBOOT_DIR="${KBOOT_DIR}/"
        #fi
        ;;
        *)
          fail "not a known command line format $KERNEL_CMD_LINE_RAW"
        ;;
  esac

  if [[ ! "$KERNEL_CMD_LINE" =~ boot= ]] ; then
    KERNEL_CMD_LINE="$KERNEL_CMD_LINE boot=local"
  fi

  if [ "$DEBUG" == "TRUE" ] ; then
    if [[ ! "$KERNEL_CMD_LINE" =~ debug ]] ; then
      KERNEL_CMD_LINE="$KERNEL_CMD_LINE debug"
    fi
  fi

  inform "KERNEL_CMD_LINE=$KERNEL_CMD_LINE"
  # inform "BOOT_DIR=$BOOT_DIR"

  if [ -z "$(whereis -b update-grub)" ] || [ -z "$(whereis -b grub-reboot)" ] ; then
      fail "failed to ensure required programs update-grub, grub-reboot"
  fi

  if [ ! -d /etc/grub.d ] ; then
      fail "grub configuration not found"
  fi

# TODO: make grub HD num from hdDev, just assuming 0 for now

  GRUB_INSTALL="TRUE"

  if [ -n "$GRUB_CFG" ] ; then
    if [ ! -f "${HOME_DIR}/${GRUB_CFG}" ] ; then
      fail "grub config not found: ${GRUB_CFG}"
    fi
  else
    # TODO: use up to date grub config
    cat << EOI > ${HOME_DIR}/grub.cfg
serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1
default=boot
timeout=0

menuentry 'boot'{
linux /vmlinuz root=LABEL=resin-rootA rootwait quiet loglevel=0 splash udev.log-priority=3 vt.global_cursor_default=0 intel_idle.max_cstate=1
}
EOI
    GRUB_CFG="grub.cfg"
  fi


  if [ ! "$NO_SETUP" == "TRUE" ] ; then

    debug setupBootCfg_other "looking for boot device blkid"

    if [ -d /dev/disk/by-uuid ] ; then
      for fname in /dev/disk/by-uuid/* ; do
        debug setupBootCfg_other "looking at $fname"
        linkedFile=$(readlink ${fname})
        debug setupBootCfg_other "go <${linkedFile}>"
        if [ "$(basename $ROOT_FS)" == "$(basename $linkedFile)" ] ; then
          # debug setupBootCfg_other "found ${uuid} for ${ROOT_FS}"
          partId=$(basename "$fname")
          break
        fi
      done
    fi

    if [ -n "${partId}" ] ; then
      inform "found uuid: ${partId} for boot drive ${ROOT_FS}"
    fi

    if [ -n "$partId" ] ; then
      local setRoot="search --no-floppy --fs-uuid --set=root $partId"
    fi

    if [ "$GPT_TABLE" == "TRUE" ] ; then
      local partMod="part_gpt"
      if [ -z "$setRoot" ] ; then
        local setRoot="set root='${GRUB_BOOT_DEV},gpt${ROOT_PART_NO}'"
      fi
    else
      local partMod="part_msdos"
      if [ -z "$setRoot" ] ; then
        local setRoot="set root='${GRUB_BOOT_DEV},msdos${ROOT_PART_NO}'"
      fi
    fi

    inform "grub config, set root: $setRoot"

    cat <<EOI > /etc/grub.d/42_resin
#!/bin/sh
exec tail -n +3 \$0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.

menuentry "resin-migration" {
  insmod $partMod
  insmod ext2

  $setRoot
  linux $KERNEL_CMD_LINE
  initrd  ${BOOT_DIR}/${INITRAMFS_NAME}
}
EOI
    chmod +x /etc/grub.d/42_resin

    inform "updating grub config using update-grub"
    update-grub || fail "failed to update grub config"
    inform "calling grub-reboot resin-migration"
    grub-reboot resin-migration
    RESTORE_BOOT_CFG_STAGE1="rm /etc/grub.d/42_resin && update-grub"
    RESTORE_BOOT_CFG_STAGE2=
else
    inform "boot setup is disabled, NO_SETUP=$NO_SETUP"
fi
}

####################################################################################
####################################################################################
# main : create initramfs & install it
####################################################################################
####################################################################################

# DEBUG_FUNCTS="migrate_this_wifi wificfg_from_wpa"
DEBUG_FUNCTS="main setupBootCfg_bb setupBootCfg_rpi getCmdArgs"

# script namme for logging
SCRIPT_NAME="balena-stage1"

CONFIG_FILE=balena-migrate.conf
HOME_DIR=./
UUID=

color ON

debug main "checking command line args"

getCmdArgs "$@"

if [[ $EUID -ne 0 ]]; then
    fail "This script must be run as root"
fi

if [ -n "$PARAM_HOME_DIR" ] ; then
  HOME_DIR=$PARAM_HOME_DIR
fi

if [ -n "$PARAM_CONFIG_FILE" ] ; then
  CONFIG_FILE=$PARAM_CONFIG_FILE
fi

inform "using config file:  $CONFIG_FILE"

# let config file override some of the settings at the top of the file
if [[ "$CONFIG_FILE" =~ ^/.* ]] ; then
  # debug main " absolute path"
  if [ -f "$CONFIG_FILE" ] ; then
    . "$CONFIG_FILE"
  else
    fail "config file not found ${CONFIG_FILE}"
  fi
else
  # debug main " relative path"
  if [ -f "${HOME_DIR}/${CONFIG_FILE}" ] ; then
    . "${HOME_DIR}/${CONFIG_FILE}"
  else
    if [ -f "${CONFIG_FILE}" ] ; then
      . "${CONFIG_FILE}"
    else
      fail "config file could not be found ${CONFIG_FILE}"
    fi
  fi
fi

if [ -n "$PARAM_HOME_DIR" ] ; then
  # cmd line params take precedence over config file
  HOME_DIR=$PARAM_HOME_DIR
fi
inform "using home dir:     $HOME_DIR"

if [ -n "$PARAM_UUID" ] ; then
  # cmd line params take precedence over config file
  BALENA_UUID="$PARAM_UUID"
fi

if [ -n "$PARAM_BALENA_CONFIG" ] ; then
  # cmd line params take precedence over config file
  BALENA_CONFIG="$PARAM_BALENA_CONFIG"
fi

# default grub config type
GRUB_BOOT_TYPE="legacy"

# name of initramfs to be created/used expected in $HOMEDIR
INITRAMFS_NAME="balena-migrate-initramfs-$(uname -r)"

# raspi config.txt to modify
CONFIG_TXT="/boot/config.txt"
# raspi cmdline.txt to modify
CMDLINE_TXT="/boot/cmdline.txt"
# supported / tested OSSE's so far
SUPPORTED_OSSES="ubuntu-18.04 ubuntu-14.04 raspbian-9 debian-9"
# supported / tested platforms so far
SUPPORTED_ARCHS="x86_64 armv7l i686"

# mappings of RPi rev numbers to device types
RASPI_1_REVS="0002 0003 0004 0005 0006 0007 0008 0009 000d 000e 000f 0010 0011 0012 0013 0014 0015 900092 900093	920093 9000c1 900021 900032 900092 900093 920093 9000c1"
RASPI_2_REVS="a01040 a01041 a21041 a22042"
RASPI_3_REVS="a02082 a020a0 a22082 a32082 a020d3"

# minimum supported grub version
GRUB_MIN_VER=2
# default boot directory
BOOT_DIR=/boot
# where the migrate conf is created - DO NOT MODIFY hardcoded in initramfs scripts
MIGRATE_CONF=/etc/balena-migrate-stage2.conf

# WPA_SUPP_CONF="/etc/wpa_supplicant/wpa_supplicant.conf"
WPA_SUPP_CONF="/etc/wpa_supplicant/wpa_supplicant.conf"
NMGR_DIR="/etc/NetworkManager/system-connections"

S2_ORIG_BOOT_MNT="/orig-boot"
S2_BOOT_PATH=
S2_MOUNT_BOOT=

S2_ROOTMOUNT='${rootmnt}'
S2_BOOTMOUNT='${ORIG_BOOT_MNT}'

RESTORE_BOOT_CFG_STAGE1=
RESTORE_BOOT_CFG_STAGE2=


inform "establishing required programs"

# TODO: Check / install tools needed for initramfs too
#       possible candidates: parted (on debian, beaglebone) blkid

INITRAM_REQUIRED_PGMS="cat cp dd df dirname echo expr grep gzip ls lsblk mkdir mv parted partprobe reboot stat sync touch udevadm"
REQUIRED_PGMS="awk file findmnt lsblk mkinitramfs parted readlink sed openssl"
checkPgms $REQUIRED_PGMS

inform "checked required programs"

inform "LOG_DEBUG=${LOG_DEBUG}, DEBUG_FUNCTS=${DEBUG_FUNCTS}"

inform "checking required files"
if [[ ! $HOME_DIR =~ ^/.* ]] ; then
  CURR_DIR=$(pwd)
  cd $HOME_DIR || fail "invalid/non existant HOME_DIR: $HOME_DIR"
  HOME_DIR=$(pwd)
  cd $CURR_DIR
fi

if [ ! -d "$HOME_DIR" ] ; then
  fail "homedir does not exist: $HOME_DIR"
fi

inform "HOME_DIR=$HOME_DIR"

if [ -z "$IMAGE_NAME" ] || [ ! -f "${HOME_DIR}/$IMAGE_NAME" ] ; then
  fail "missing image file: $IMAGE_NAME"
fi

##########################################
# check / repack image file
##########################################

TMP_IMG="${HOME_DIR}/${IMAGE_NAME}"
FTYPE=$(file -b "${TMP_IMG}")

if [[ ! $FTYPE =~ ^gzip\ compressed\ data.* ]] ; then
  if [[ $FTYPE =~ ^Zip\ archive\ data.* ]]  ; then
    inform "image file appears to be a zip archive, unzipping and repacking in gzip format.."
    TMP_DIR=$(mktemp -d -p "${HOME_DIR}")
    unzip "${TMP_IMG}" -d "$TMP_DIR" || fail "failed to unzip ${TMP_IMG}"
    TMP_IMG="${TMP_DIR}/$(ls "$TMP_DIR")"
    inform "got ${TMP_IMG}"
    FTYPE=$(file -b "$TMP_IMG")
  fi

  if [[ $FTYPE =~ ^DOS/MBR\ boot\ sector.* ]]  ; then
    inform "gzipping uncompressed image file $TMP_IMG.."
    gzip "$TMP_IMG" || fail "failed to gzip $TMP_IMG"
    # TMP_IMG=$(basename "${TMP_IMG}")
    IMAGE_NAME=$(expr match "${TMP_IMG}" '.*/\([^/]\+/[^/]\+\)$')
    IMAGE_NAME="${IMAGE_NAME}.gz" 
    # IMAGE_NAME=${TMP_IMG#"$HOME_DIR/"}.gz
    # IMAGE_NAME="${TMP_DIR}/${TMP_IMG}.gz"
    if [ -f "${HOME_DIR}/${IMAGE_NAME}" ] ; then
      inform "working with image $IMAGE_NAME"
    else
      fail "compressed image ${HOME_DIR}/${IMAGE_NAME} does not exist"
    fi
  else
    fail "cannot make sense of unzipped image file $TMP_IMG - expecting an image file, got $FTYPE"
  fi
else
  FTYPE=$(file -bz "${HOME_DIR}/${IMAGE_NAME}")
  if [[ ! $FTYPE =~ ^DOS/MBR\ boot\ sector.* ]]  ; then
    fail "cannot make sense of image file $TMP_IMG - expecting a gzipped image file, got $FTYPE"
  fi
fi

##########################################
# detect device / check for correct image ?
##########################################

ARCH=$(uname -m)

if ! listContains "$SUPPORTED_ARCHS" $ARCH ; then
  fail "not a supported architecture: $ARCH"
fi

case $ARCH in
  armv*)
    checkArmDevs
    ;;
  x86_64)
    inform "ARCH=$ARCH"
    devType="x86_64"
    if [[ ! $IMAGE_NAME =~ genericx86-64 ]] ; then
        fail "expected genericx86-64 image, got $IMAGE_NAME"
    fi
    ;;
  i686)
    devType="i686"
    inform "ARCH=$ARCH"
    if [[ ! $IMAGE_NAME =~ intel-core2-32 ]] ; then
        fail "expected intel-core2-32 image, got $IMAGE_NAME"
    fi
    ;;
  *)
    fail "unknown / unsupported architecture: $ARCH"
    ;;
esac

checkPgms $INITRAM_REQUIRED_PGMS

KERNEL_VER=$(uname -r)
inform "KERNEL_VER=$KERNEL_VER"

OS_VERSION=$(checkOs)
inform "OS_VERSION=$OS_VERSION"

if ! listContains "${SUPPORTED_OSSES}" ${OS_VERSION} ; then
    fail "not a supported OS ${OS_VERSION}"
fi

if [ "$MK_INITRAMFS" == "TRUE" ] && [ ! -d "${HOME_DIR}/initramfs-tools" ] ; then
  fail "missing image directory: ${HOME_DIR}/initramfs-tools"
fi

getBootInfo

inform "root partition: ${ROOT_FS} boot partition: ${BOOT_FS} EFI partition: ${EFI_FS}"

TMP=($(splitPartName ${BOOT_FS}))

BOOT_PAD=${TMP[3]}
BOOT_DEV=${TMP[0]}/${TMP[1]}
BOOT_PART_NO=${TMP[2]}

TMP=($(splitPartName ${ROOT_FS}))
ROOT_PART_NO=${TMP[2]}

if [ "$BOOT_DEV" != "${TMP[0]}/${TMP[1]}" ] ; then
  fail "unsupported boot configuration /boot is on a separate drive from / "
fi

if [ $BOOT_PART_NO -eq $ROOT_PART_NO ] ; then
  S2_BOOT_PATH="${S2_ROOTMOUNT}/boot"
  S2_MOUNT_BOOT=
  S1_BOOT_PATH="/boot"
else
  S2_MOUNT_BOOT="TRUE"
  S2_BOOT_PATH="${S2_BOOTMOUNT}"
  # TODO: determine path to /boot mount
  S1_BOOT_PATH="/boot"
fi

debug main "S2_BOOT_PATH=$S2_BOOT_PATH S2_MOUNT_BOOT=$S2_MOUNT_BOOT"

while read line ;
do
  # inform "parted line: $line"

  if [[ $line =~ ^Partition\ Table:\ gpt ]] ; then
    inform "gpt partition table found"
    GPT_TABLE="TRUE"
    continue
  fi

  # determine BOOT partitions FS type
  if [[ $line =~ ^${BOOT_PART_NO}.* ]] ; then
    parts=($line)
    if [ "$GPT_TABLE" == "TRUE" ] ; then
      BOOT_FS_TYPE=${parts[4]}
    else
      BOOT_FS_TYPE=${parts[5]}
    fi

    if [[ $BOOT_FS_TYPE =~ ^fat[0-9]+$ ]]  ; then
      BOOT_FS_TYPE="vfat"
    fi
    break
  fi
done < <(parted -s ${BOOT_DEV} print)

inform "ROOT_DEV=${BOOT_DEV}, FS type: $BOOT_FS_TYPE"

###########################
## create boot configuration
###########################

case "$devType" in
    armv7_rpi*)
      inform "performing boot setup for RPI: $devType"
      setupBootCfg_rpi
    ;;
    armv7_bb*)
      inform "performing boot setup for Beaglebone: $devType"
      setupBootCfg_bb
    ;;
    *)
      inform "performing boot setup for other: $devType"
      setupBootCfg_other
    ;;
esac

###########################
## migrate network config
###########################

NETWORK_CONFIGS=

if [ -n "$BALENA_CONFIG" ] && [ -f "${HOME_DIR}/${BALENA_CONFIG}" ] && [ "$BALENA_WIFI" == "TRUE" ] ; then
  inform "scanning ${HOME_DIR}/${BALENA_CONFIG} for wifi"
  while read line ;
  do
    if [[ $line =~ ,*[\ ]*\"wifiSsid\"[\ ]*\: ]] ; then
      wifiSsid=$(expr match "$line" '.*"wifiSsid"[ ]*:[ ]*"\([^"]\+\)".*')
    fi

    if [[ $line =~ ,*[\ ]*\"wifiKey\"[\ ]*\: ]] ; then
      wifiKey=$(expr match "$line" '.*"wifiKey"[ ]*:[ ]*"\([^"]\+\)".*')
    fi
  done < "${HOME_DIR}/${BALENA_CONFIG}"

  if [ -n "$wifiSsid" ] ; then
    inform "creating config for wifi $wifiSsid"
    create_nmgr_file 1 $wifiSsid $wifiKey
    HAS_WIFI_CFG="TRUE"
  fi
fi

if [ "$MIGRATE_ALL_WIFIS" == "TRUE" ] || [ -n "$MIGRATE_WIFI_CFG" ] ; then
  if [ -f "$WPA_SUPP_CONF" ] ; then
    wificfg_from_wpa
  else
    if [ -d "$NMGR_DIR" ] ; then
      wificfg_from_nmgr
    else
      warn "no supported wifi config found"
    fi
  fi

  if [ -n "$NETWORK_CONFIGS" ] ; then
    echo "NETWORK_CONFIGS=\"$NETWORK_CONFIGS\"" >> ${MIGRATE_CONF}
    echo "" >> ${MIGRATE_CONF}
  fi
fi

######################################################
## inject UUID into balena config
######################################################

if [ -n "$BALENA_CONFIG" ] ; then

  if [ -f "${HOME_DIR}/$BALENA_CONFIG" ]  && [ -n "$BALENA_UUID" ] ; then
    if [ "$BALENA_UUID" == "create" ] ||  [ "$BALENA_UUID" == "CREATE" ] ; then
      BALENA_UUID=$(openssl rand -hex 16) || fail "failed to create UUID"
    fi

    inform "using UUID: $BALENA_UUID"

    BALENA_TMP_FILE=$(mktemp -p ${HOME_DIR})
    BALENA_TMP_FILE=$(basename ${BALENA_TMP_FILE})

    # cp "$BALENA_CONFIG" "$BALENA_TMP_FILE" || fail "failed to copy $BALENA_CONFIG to $BALENA_TMP_FILE"
    uuidConf='"uuid":"'$BALENA_UUID'"'
    debug main "uuidConf=$uuidConf"
    if grep "\"uuid\":" "$BALENA_CONFIG" >/dev/null 2>&1  ; then
      debug main "replace UUID with $BALENA_UUID"
      sed 's/\("uuid":"[^"]\+"\)/'$uuidConf'/g' "$BALENA_CONFIG" > "${HOME_DIR}/$BALENA_TMP_FILE" || fail "failed to replace uuid "
    else
      debug main "add UUID $BALENA_UUID"
      sed 's/\(}\)\s*$/,'$uuidConf'}/g' "$BALENA_CONFIG"  > "${HOME_DIR}/$BALENA_TMP_FILE" || fail "failed to add uuid"
    fi
    BALENA_CONFIG="$BALENA_TMP_FILE"
  fi
fi

###########################
## write /etc/migrate.conf
###########################


cat <<EOI > ${MIGRATE_CONF}
#!/bin/sh
# DO NOT EDIT ! This file is supposed to be created by stage1 script

REQUIRED_PGMS="$INITRAM_REQUIRED_PGMS"
LOG_DRIVE=${LOG_DRIVE}
LOG_FS_TYPE=${LOG_FS_TYPE}
LOG_MOUNT_DIR=/extlog
LOG_FILE=migrate.log

DEV_TYPE=$devType

BOOT_DEV=${BOOT_DEV}

ORIG_BOOT_MNT=${S2_ORIG_BOOT_MNT}
RESTORE_BOOT=${RESTORE_BOOT_CFG_STAGE2}
MOUNT_BOOT=${S2_MOUNT_BOOT}

ORIG_BOOT_PART=${BOOT_FS}
ORIG_ROOT_PART=${ROOT_FS}
ORIG_BOOT_FS_TYPE=${BOOT_FS_TYPE}

HOME_DIR=${HOME_DIR}
IMAGE_FILE=${IMAGE_NAME}
BACKUP_FILE=${BACKUP_FILE}

MIGRATE_TMP=/balena-migrate

BOOT_MNT_DIR=/resin-boot
BOOT_PART_NAME=${BOOT_DEV}${BOOT_PAD}1
BOOT_PART_TYPE=vfat

DATA_MNT_DIR=/resin-data
DATA_PART_NAME=${BOOT_DEV}${BOOT_PAD}6
DATA_PART_TYPE=ext4

NO_FLASH=${NO_FLASH}

TERM_EXIT="${TERM_EXIT}"

GRUB_INSTALL=${GRUB_INSTALL}
GRUB_CFG="$GRUB_CFG"
GRUB_BOOT_TYPE=${GRUB_BOOT_TYPE}
GRUB_PART_GPT=${GPT_TABLE}

BALENA_CONFIG="${BALENA_CONFIG}"
MEM_MIN_FREE=${MEM_MIN_FREE_S2}
# BALENA_UUID=${BALENA_UUID}

NETWORK_CONFIGS="$NETWORK_CONFIGS"

EOI

###########################
## create initramfs
###########################

if [ "${MK_INITRAMFS}" == TRUE ] ; then
    # set gzip compression
    sed -i 's/^\(COMPRESS\s*=\s*\).*$/\1gzip/' "${HOME_DIR}/initramfs-tools/initramfs.conf" || fail "failed to modify ${HOME_DIR}/initramfs-tools/initramfs.conf"

    OPTS="-d ${HOME_DIR}/initramfs-tools -o ${HOME_DIR}/${INITRAMFS_NAME}"
    if [ "$MK_INITRAM_VERBOSE" == "TRUE" ] ; then
      OPTS="-v $OPTS"
    fi

    if [ "$MK_INITRAM_RETAIN" == "TRUE" ] ; then
      OPTS="-k $OPTS"
    fi

    inform "creating initramfs: mkinitramfs $OPTS"
    mkinitramfs $OPTS || fail "failed to create initramfs in ${HOME_DIR}/${INITRAMFS_NAME}"

    inform "copying ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"
    cp ${HOME_DIR}/${INITRAMFS_NAME} "${BOOT_DIR}/" || fail "failed to copy ${HOME_DIR}/${INITRAMFS_NAME} to ${BOOT_DIR}/"
fi

if [ -n "$BALENA_TMP_FILE" ] && [ -f "$BALENA_TMP_FILE" ] ; then
  rm "$BALENA_TMP_FILE"
fi

###########################
## create backup
###########################

if [ -n "$BACKUP_FILE" ] ; then
  if [ -n "$BACKUP_SCRIPT" ] && [ -f "${HOME_DIR}/${BACKUP_SCRIPT}" ] ; then
    inform "invoking backup script using: ${HOME_DIR}/${BACKUP_SCRIPT} ${HOME_DIR}/${BACKUP_FILE}"
    ${HOME_DIR}/${BACKUP_SCRIPT} ${HOME_DIR}/${BACKUP_FILE} || fail "backup script ${HOME_DIR}/${BACKUP_SCRIPT} returned error code"
    inform "...done"
  else
    if [ -n "$BACKUP_DIRECTORIES" ] ; then
      if [ -f "${HOME_DIR}/$BACKUP_FILE" ] ; then
        rm ${HOME_DIR}/$BACKUP_FILE || true
      fi
      inform "creating backup using tar -czf ${HOME_DIR}/$BACKUP_FILE $BACKUP_DIRECTORIES"
      tar -czf "${HOME_DIR}/$BACKUP_FILE" $BACKUP_DIRECTORIES > /dev/null || fail "failed to create backup using tar -czf ${HOME_DIR}/$BACKUP_FILE $BACKUP_DIRECTORIES"
      inform "...done"
    fi
  fi

  if [ ! -f ${HOME_DIR}/${BACKUP_FILE} ] ; then
    warn "no backup file created in: ${HOME_DIR}/${BACKUP_SCRIPT} ${HOME_DIR}/${BACKUP_FILE}"
  fi
fi

###########################
## check memory
###########################

totMem=`cat /proc/meminfo | grep "MemTotal:"`
totMem=`expr match "$totMem" '[^:]\+:[^0-9]\+\([0-9]\+\)[^0-9]*kB'` || true
inform "total memory:  ${totMem} kB"

leftMem=$totMem

if [ -f "${HOME_DIR}/${IMAGE_NAME}" ] ; then
  tmp=`stat -c %s "${HOME_DIR}/${IMAGE_NAME}"`
  tmp=`expr $tmp / 1024` || true
  inform "image file size: ${tmp} kB "
  leftMem=`expr ${leftMem} - ${tmp}`
fi

if [ -f "${HOME_DIR}/${BACKUP_FILE}" ] ; then
  tmp=`stat -c %s "${HOME_DIR}/${BACKUP_FILE}"`
  tmp=`expr $tmp / 1024` || true
  inform "backup file size: ${tmp} kB "
  leftMem=`expr ${leftMem} - ${tmp}`
fi


fType=$(file "${HOME_DIR}/${INITRAMFS_NAME}")
if [[ "$fType" =~ ^[^:]+:.*cpio\ archive.* ]] ; then
  tmp=`stat -c %s "${HOME_DIR}/${INITRAMFS_NAME}"`
else
  if [[ $fType =~ ^[^:]+:[\ ]*gzip.* ]] ; then
    while read line ;
    do
      if echo "$line" | grep "${INITRAMFS_NAME}" > /dev/null ; then
        tmp=$(expr match "$line" '[0-9]\+[ ]\+\([0-9]\+\) .*')
        break;
      fi
    done < <(gzip -l "${HOME_DIR}/${INITRAMFS_NAME}")
  else
    warn "unexpected initramfs format"
    tmp=`stat -c %s "${HOME_DIR}/${INITRAMFS_NAME}"`
  fi
fi

tmp=`expr $tmp / 1024` || true
inform "initramfs est. size: ${tmp} kB "
leftMem=`expr ${leftMem} - ${tmp}`

inform "Est. memory left: ${leftMem} kB "
if [ ${leftMem} -lt ${MEM_MIN_FREE_S1} ] ; then
  fail "Est. memory left is less than set threshold (${MEM_MIN_FREE_S1} kB), reduce backup size or threshold in MEM_MIN_FREE_S1"
fi

###########################
## reboot
###########################

if [ "$DO_REBOOT" == "TRUE" ] ; then
  inform "rebooting system in 5 seconds"
  sleep 5
  inform "migration successful, rebooting system in 1 second"
  sleep 1
  reboot
else
  inform "migration successful, please reboot system"
fi
